
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>aaa: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">yadro.com/course/api/adapters/aaa/auth.go (83.3%)</option>
				
				<option value="file1">yadro.com/course/api/adapters/rest/api.go (72.6%)</option>
				
				<option value="file2">yadro.com/course/api/adapters/rest/middleware/auth.go (100.0%)</option>
				
				<option value="file3">yadro.com/course/api/adapters/rest/middleware/concurrency.go (88.9%)</option>
				
				<option value="file4">yadro.com/course/api/adapters/rest/middleware/rate.go (94.7%)</option>
				
				<option value="file5">yadro.com/course/api/adapters/rest/mock/mock_rest.go (91.5%)</option>
				
				<option value="file6">yadro.com/course/api/adapters/search/mock/mock_search.go (45.9%)</option>
				
				<option value="file7">yadro.com/course/api/adapters/search/search.go (76.3%)</option>
				
				<option value="file8">yadro.com/course/api/adapters/update/mock/mock_update.go (49.1%)</option>
				
				<option value="file9">yadro.com/course/api/adapters/update/update.go (86.2%)</option>
				
				<option value="file10">yadro.com/course/api/adapters/words/mock/mock_words.go (42.9%)</option>
				
				<option value="file11">yadro.com/course/api/adapters/words/words.go (90.9%)</option>
				
				<option value="file12">yadro.com/course/api/adapters/yolo/yolo.go (0.0%)</option>
				
				<option value="file13">yadro.com/course/api/config/config.go (75.0%)</option>
				
				<option value="file14">yadro.com/course/api/main.go (0.0%)</option>
				
				<option value="file15">yadro.com/course/comic-frontend/config/config.go (0.0%)</option>
				
				<option value="file16">yadro.com/course/comic-frontend/handlers/handlers.go (0.0%)</option>
				
				<option value="file17">yadro.com/course/comic-frontend/main.go (0.0%)</option>
				
				<option value="file18">yadro.com/course/proto/search/search.pb.go (8.0%)</option>
				
				<option value="file19">yadro.com/course/proto/search/search_grpc.pb.go (0.0%)</option>
				
				<option value="file20">yadro.com/course/proto/update/update.pb.go (11.7%)</option>
				
				<option value="file21">yadro.com/course/proto/update/update_grpc.pb.go (0.0%)</option>
				
				<option value="file22">yadro.com/course/proto/words/words.pb.go (16.3%)</option>
				
				<option value="file23">yadro.com/course/proto/words/words_grpc.pb.go (2.8%)</option>
				
				<option value="file24">yadro.com/course/proto/yolo/yolo.pb.go (0.0%)</option>
				
				<option value="file25">yadro.com/course/proto/yolo/yolo_grpc.pb.go (0.0%)</option>
				
				<option value="file26">yadro.com/course/search/adapters/db/storage.go (86.8%)</option>
				
				<option value="file27">yadro.com/course/search/adapters/grpc/mock/mock_server.go (27.3%)</option>
				
				<option value="file28">yadro.com/course/search/adapters/grpc/server.go (100.0%)</option>
				
				<option value="file29">yadro.com/course/search/adapters/initiator/index_updater.go (91.7%)</option>
				
				<option value="file30">yadro.com/course/search/adapters/initiator/mock/mock_init.go (62.5%)</option>
				
				<option value="file31">yadro.com/course/search/adapters/words/mock/mock_words.go (42.9%)</option>
				
				<option value="file32">yadro.com/course/search/adapters/words/words.go (60.0%)</option>
				
				<option value="file33">yadro.com/course/search/config/config.go (75.0%)</option>
				
				<option value="file34">yadro.com/course/search/core/mock_service.go (55.8%)</option>
				
				<option value="file35">yadro.com/course/search/core/service.go (94.0%)</option>
				
				<option value="file36">yadro.com/course/search/main.go (0.0%)</option>
				
				<option value="file37">yadro.com/course/update/adapters/db/migrations.go (33.3%)</option>
				
				<option value="file38">yadro.com/course/update/adapters/db/storage.go (70.8%)</option>
				
				<option value="file39">yadro.com/course/update/adapters/grpc/mock/mock_updater.go (49.2%)</option>
				
				<option value="file40">yadro.com/course/update/adapters/grpc/server.go (100.0%)</option>
				
				<option value="file41">yadro.com/course/update/adapters/words/mock/mock_words.go (0.0%)</option>
				
				<option value="file42">yadro.com/course/update/adapters/words/words.go (90.0%)</option>
				
				<option value="file43">yadro.com/course/update/adapters/xkcd/mock/mock_xkcd.go (100.0%)</option>
				
				<option value="file44">yadro.com/course/update/adapters/xkcd/xkcd.go (91.7%)</option>
				
				<option value="file45">yadro.com/course/update/config/config.go (75.0%)</option>
				
				<option value="file46">yadro.com/course/update/core/mock/mock_service.go (0.0%)</option>
				
				<option value="file47">yadro.com/course/update/core/service.go (98.5%)</option>
				
				<option value="file48">yadro.com/course/update/main.go (0.0%)</option>
				
				<option value="file49">yadro.com/course/words/main.go (0.0%)</option>
				
				<option value="file50">yadro.com/course/words/words/words.go (100.0%)</option>
				
				<option value="file51">yadro.com/course/yolo/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package aaa

import (
        "errors"
        "fmt"
        "log/slog"
        "os"
        "time"

        "github.com/golang-jwt/jwt/v5"
)

const (
        secretKey = "something secret here" // token sign key
        adminRole = "superuser"             // token subject
)

type AAA struct {
        users    map[string]string
        tokenTTL time.Duration
        log      *slog.Logger
}

func New(tokenTTL time.Duration, log *slog.Logger) (AAA, error) <span class="cov10" title="5">{
        const adminUser = "ADMIN_USER"
        const adminPass = "ADMIN_PASSWORD"
        user, ok := os.LookupEnv(adminUser)
        if !ok </span><span class="cov1" title="1">{
                return AAA{}, fmt.Errorf("could not get admin user from enviroment")
        }</span>
        <span class="cov8" title="4">password, ok := os.LookupEnv(adminPass)
        if !ok </span><span class="cov1" title="1">{
                return AAA{}, fmt.Errorf("could not get admin password from enviroment")
        }</span>

        <span class="cov7" title="3">return AAA{
                users:    map[string]string{user: password},
                tokenTTL: tokenTTL,
                log:      log,
        }, nil</span>
}

func (a AAA) Login(name, password string) (string, error) <span class="cov8" title="4">{
        if name == "" </span><span class="cov0" title="0">{
                return "", errors.New("empty user")
        }</span>

        <span class="cov8" title="4">storedPass, exists := a.users[name]
        if !exists || storedPass != password </span><span class="cov4" title="2">{
                a.log.Warn("invalid login attempt", "user", name)
                return "", errors.New("invalid credentials")
        }</span>

        <span class="cov4" title="2">token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
                "sub": adminRole,
                "exp": time.Now().Add(a.tokenTTL).Unix(),
        })

        tokenString, err := token.SignedString([]byte(secretKey))
        if err != nil </span><span class="cov0" title="0">{
                a.log.Error("failed to sign token", "error", err)
                return "", fmt.Errorf("token generation failed")
        }</span>

        <span class="cov4" title="2">return tokenString, nil</span>
}

func (a AAA) Verify(tokenString string) error <span class="cov8" title="4">{
        token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) </span><span class="cov7" title="3">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method")
                }</span>
                <span class="cov7" title="3">return []byte(secretKey), nil</span>
        })

        <span class="cov8" title="4">if err != nil || !token.Valid </span><span class="cov4" title="2">{
                a.log.Warn("invalid token", "error", err)
                return errors.New("invalid token")
        }</span>

        <span class="cov4" title="2">subject, err := token.Claims.GetSubject()
        if err != nil </span><span class="cov0" title="0">{
                a.log.Error("no subject", "error", err)
                return errors.New("incomplete token")
        }</span>
        <span class="cov4" title="2">if subject != adminRole </span><span class="cov1" title="1">{
                a.log.Error("not admin", "subject", subject)
                return errors.New("not authorized")
        }</span>
        <span class="cov1" title="1">return nil</span>

}
</pre>
		
		<pre class="file" id="file1" style="display: none">package rest

import (
        "encoding/json"
        "errors"
        "io"
        "log/slog"
        "net/http"
        "strconv"
        "strings"
        "sync/atomic"
        "yadro.com/course/api/core"
)

type Authenticator interface {
        Login(user, password string) (string, error)
}

func NewLoginHandler(log *slog.Logger, auth Authenticator) http.HandlerFunc <span class="cov7" title="3">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov7" title="3">{
                var credentials struct {
                        Name     string `json:"name"`
                        Password string `json:"password"`
                }

                if err := json.NewDecoder(r.Body).Decode(&amp;credentials); err != nil </span><span class="cov1" title="1">{
                        log.Debug("failed to decode login request", "error", err)
                        http.Error(w, "Invalid request body", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov4" title="2">token, err := auth.Login(credentials.Name, credentials.Password)
                if err != nil </span><span class="cov1" title="1">{
                        log.Warn("login failed", "user", credentials.Name, "error", err)
                        http.Error(w, "Unauthorized", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov1" title="1">w.Header().Set("Content-Type", "text/plain")
                if _, err := w.Write([]byte(token)); err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to write token")
                        return
                }</span>
        }
}

type PingResponse struct {
        Replies map[string]string `json:"replies"`
}

func NewPingHandler(log *slog.Logger, pingers map[string]core.Pinger) http.HandlerFunc <span class="cov4" title="2">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov4" title="2">{
                reply := PingResponse{
                        Replies: make(map[string]string),
                }

                for name, pinger := range pingers </span><span class="cov8" title="4">{
                        if err := pinger.Ping(r.Context()); err != nil </span><span class="cov1" title="1">{
                                reply.Replies[name] = "unavailable"
                                log.Error("one of services is not available", "service", name, "error", err.Error())
                                continue</span>
                        }
                        <span class="cov7" title="3">reply.Replies[name] = "ok"</span>
                }

                <span class="cov4" title="2">w.Header().Set("Content-Type", "application/json")
                if err := json.NewEncoder(w).Encode(reply); err != nil </span><span class="cov0" title="0">{
                        log.Error("cannot encode reply", "error", err)
                        http.Error(w, "Internal Server Error", http.StatusInternalServerError)
                }</span>
        }
}

type WordsResponse struct {
        Words []string `json:"words"`
        Total int      `json:"total"`
}

func NewWordsHandler(log *slog.Logger, norm core.Normalizer) http.HandlerFunc <span class="cov8" title="4">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="4">{
                phrase := r.URL.Query().Get("phrase")
                if phrase == "" </span><span class="cov1" title="1">{
                        log.Error("missing phrase")
                        http.Error(w, "missing phrase", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov7" title="3">words, err := norm.Norm(r.Context(), phrase)
                if err != nil </span><span class="cov4" title="2">{
                        log.Error("bad reply from normalizer", "error", err)
                        if errors.Is(err, core.ErrBadArguments) </span><span class="cov1" title="1">{
                                http.Error(w, err.Error(), http.StatusBadRequest)
                                return
                        }</span>
                        <span class="cov1" title="1">http.Error(w, err.Error(), http.StatusInternalServerError)
                        return</span>
                }

                <span class="cov1" title="1">reply := WordsResponse{
                        Words: words,
                        Total: len(words),
                }

                w.Header().Set("Content-Type", "application/json")
                if err := json.NewEncoder(w).Encode(reply); err != nil </span><span class="cov0" title="0">{
                        log.Error("cannot encode reply", "error", err)
                        http.Error(w, "Internal Server Error", http.StatusInternalServerError)
                }</span>
        }
}

type UpdateStatsResponse struct {
        WordsTotal    int `json:"words_total"`
        WordsUnique   int `json:"words_unique"`
        ComicsFetched int `json:"comics_fetched"`
        ComicsTotal   int `json:"comics_total"`
}

func NewUpdateStatsHandler(log *slog.Logger, updater core.Updater) http.HandlerFunc <span class="cov4" title="2">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov4" title="2">{
                stats, err := updater.Stats(r.Context())
                if err != nil </span><span class="cov1" title="1">{
                        log.Error("failed to get stats", "error", err)
                        http.Error(w, "Internal Server Error", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov1" title="1">reply := UpdateStatsResponse{
                        WordsTotal:    stats.WordsTotal,
                        WordsUnique:   stats.WordsUnique,
                        ComicsFetched: stats.ComicsFetched,
                        ComicsTotal:   stats.ComicsTotal,
                }

                w.Header().Set("Content-Type", "application/json")
                if err := json.NewEncoder(w).Encode(reply); err != nil </span><span class="cov0" title="0">{
                        log.Error("cannot encode reply", "error", err)
                        http.Error(w, "Internal Server Error", http.StatusInternalServerError)
                }</span>
        }
}

type UpdateStatusResponse struct {
        Status string `json:"status"`
}

var (
        updates atomic.Bool
)

func NewUpdateStatusHandler(log *slog.Logger, updater core.Updater) http.HandlerFunc <span class="cov4" title="2">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov4" title="2">{
                status := "idle"
                if updates.Load() </span><span class="cov1" title="1">{
                        status = "running"
                }</span>

                <span class="cov4" title="2">reply := UpdateStatusResponse{
                        Status: status,
                }

                w.Header().Set("Content-Type", "application/json")
                if err := json.NewEncoder(w).Encode(reply); err != nil </span><span class="cov0" title="0">{
                        log.Error("cannot encode reply", "error", err)
                        http.Error(w, "Internal Server Error", http.StatusInternalServerError)
                }</span>
        }
}

func NewUpdateHandler(log *slog.Logger, updater core.Updater) http.HandlerFunc <span class="cov8" title="4">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="4">{
                if !updates.CompareAndSwap(false, true) </span><span class="cov1" title="1">{
                        log.Info("update already running")
                        w.WriteHeader(http.StatusAccepted)
                        return
                }</span>

                <span class="cov7" title="3">log.Info("update started")

                err := updater.Update(r.Context())
                if err != nil </span><span class="cov4" title="2">{
                        if errors.Is(err, core.ErrAlreadyExists) </span><span class="cov1" title="1">{
                                w.WriteHeader(http.StatusAccepted)
                                return
                        }</span>
                        <span class="cov1" title="1">log.Error("failed to update", "error", err)
                        http.Error(w, "Internal Server Error", http.StatusInternalServerError)
                        return</span>
                }

                <span class="cov1" title="1">updates.Store(false)
                log.Info("update finished")

                w.WriteHeader(http.StatusOK)</span>
        }
}

func NewDropHandler(log *slog.Logger, updater core.Updater) http.HandlerFunc <span class="cov4" title="2">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov4" title="2">{
                if err := updater.Drop(r.Context()); err != nil </span><span class="cov1" title="1">{
                        log.Error("failed to drop database", "error", err)
                        http.Error(w, "Internal Server Error", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov1" title="1">w.WriteHeader(http.StatusOK)</span>
        }
}

type SearchResponse struct {
        Comics []core.Comics `json:"comics"`
        Total  int32         `json:"total"`
}

func NewSearchHandler(log *slog.Logger, client core.Searcher) http.HandlerFunc <span class="cov10" title="5">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov10" title="5">{
                ctx := r.Context()

                phrase := r.URL.Query().Get("phrase")
                limitStr := r.URL.Query().Get("limit")

                limit := 10
                if limitStr != "" </span><span class="cov10" title="5">{
                        limitInt, err := strconv.Atoi(limitStr)
                        if err != nil || limitInt &lt; 1 </span><span class="cov1" title="1">{
                                log.Warn("invalid limit", "limit", limitStr)
                                http.Error(w, "invalid limit", http.StatusBadRequest)
                                return
                        }</span>
                        <span class="cov8" title="4">limit = limitInt</span>
                }

                <span class="cov8" title="4">if phrase == "" </span><span class="cov1" title="1">{
                        log.Warn("phrase is required")
                        http.Error(w, "phrase is required", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov7" title="3">comics, total, err := client.Search(ctx, phrase, int32(limit))
                if err != nil </span><span class="cov4" title="2">{
                        if errors.Is(err, core.ErrBadArguments) </span><span class="cov1" title="1">{
                                log.Warn("bad request", "error", err)
                                http.Error(w, "bad request", http.StatusBadRequest)
                                return
                        }</span>
                        <span class="cov1" title="1">log.Error("search failed", "error", err)
                        http.Error(w, "internal server error", http.StatusInternalServerError)
                        return</span>
                }

                <span class="cov1" title="1">response := SearchResponse{
                        Comics: comics,
                        Total:  total,
                }

                w.Header().Set("Content-Type", "application/json")
                if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to encode response", "error", err)
                        http.Error(w, "failed to encode response", http.StatusInternalServerError)
                }</span>
        }
}

type IndexSearchResponse struct {
        Comics []core.Comics `json:"comics"`
        Total  int32         `json:"total"`
}

func NewSearchIndexHandler(log *slog.Logger, client core.Searcher) http.HandlerFunc <span class="cov10" title="5">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov10" title="5">{
                ctx := r.Context()

                phrase := r.URL.Query().Get("phrase")
                limitStr := r.URL.Query().Get("limit")

                limit := 10
                if limitStr != "" </span><span class="cov10" title="5">{
                        limitInt, err := strconv.Atoi(limitStr)
                        if err != nil || limitInt &lt; 1 </span><span class="cov1" title="1">{
                                log.Warn("invalid limit", "limit", limitStr)
                                http.Error(w, "invalid limit", http.StatusBadRequest)
                                return
                        }</span>
                        <span class="cov8" title="4">limit = limitInt</span>
                }

                <span class="cov8" title="4">if phrase == "" </span><span class="cov1" title="1">{
                        log.Warn("phrase is required")
                        http.Error(w, "phrase is required", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov7" title="3">comics, total, err := client.IndexSearch(ctx, phrase, int32(limit))
                if err != nil </span><span class="cov4" title="2">{
                        if errors.Is(err, core.ErrBadArguments) </span><span class="cov1" title="1">{
                                log.Warn("bad request", "error", err)
                                http.Error(w, "bad request", http.StatusBadRequest)
                                return
                        }</span>
                        <span class="cov1" title="1">log.Error("index search failed", "error", err)
                        http.Error(w, "internal server error", http.StatusInternalServerError)
                        return</span>
                }

                <span class="cov1" title="1">response := IndexSearchResponse{
                        Comics: comics,
                        Total:  total,
                }

                w.Header().Set("Content-Type", "application/json")
                if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to encode response", "error", err)
                        http.Error(w, "failed to encode response", http.StatusInternalServerError)
                }</span>
        }
}

type DetectHandler struct {
        log          *slog.Logger
        yoloClient   core.YoloDetector
        searchClient core.Searcher
}

func NewDetectHandler(
        log *slog.Logger,
        yoloClient core.YoloDetector,
        searchClient core.Searcher,
) *DetectHandler <span class="cov0" title="0">{
        return &amp;DetectHandler{
                log:          log,
                yoloClient:   yoloClient,
                searchClient: searchClient,
        }
}</span>

func (h *DetectHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">file, _, err := r.FormFile("image")
        if err != nil </span><span class="cov0" title="0">{
                h.log.Error("failed to get image", "error", err)
                http.Error(w, "Image required", http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">defer file.Close()

        imgData, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Error("failed to read image", "error", err)
                http.Error(w, "Internal error", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">results, err := h.yoloClient.Detect(r.Context(), imgData)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Error("yolo detection failed", "error", err)
                http.Error(w, "Detection failed", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">var labels []string
        for _, r := range results </span><span class="cov0" title="0">{
                labels = append(labels, r.Label)
        }</span>
        <span class="cov0" title="0">phrase := strings.Join(labels, " ")

        comics, total, err := h.searchClient.Search(r.Context(), phrase, 10)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Error("search failed", "error", err)
                if errors.Is(err, core.ErrBadArguments) </span><span class="cov0" title="0">{
                        http.Error(w, "bad request", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, "internal server error", http.StatusInternalServerError)
                return</span>
        }

        <span class="cov0" title="0">response := IndexSearchResponse{
                Comics: comics,
                Total:  total,
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                h.log.Error("failed to encode response", "error", err)
                http.Error(w, "failed to encode response", http.StatusInternalServerError)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package middleware

import (
        "net/http"
        "strings"
)

type TokenVerifier interface {
        Verify(token string) error
}

func Auth(next http.HandlerFunc, verifier TokenVerifier) http.HandlerFunc <span class="cov10" title="5">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov10" title="5">{

                authHeader := r.Header.Get("Authorization")
                if authHeader == "" </span><span class="cov1" title="1">{
                        http.Error(w, "Authorization header is missing", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov8" title="4">if !strings.HasPrefix(authHeader, "Token ") </span><span class="cov1" title="1">{
                        http.Error(w, "Invalid authorization format. Expected 'Token &lt;jwt&gt;'", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov7" title="3">token := strings.TrimSpace(strings.TrimPrefix(authHeader, "Token "))
                if token == "" </span><span class="cov1" title="1">{
                        http.Error(w, "Empty token", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov4" title="2">if err := verifier.Verify(token); err != nil </span><span class="cov1" title="1">{
                        http.Error(w, "Invalid token: "+err.Error(), http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov1" title="1">next(w, r)</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package middleware

import (
        "log/slog"
        "net/http"
)

func Concurrency(next http.HandlerFunc, limit int) http.HandlerFunc <span class="cov7" title="3">{
        var (
                semaphore = make(chan struct{}, limit)
                logger    = slog.Default()
                release   = func() </span><span class="cov8" title="4">{ &lt;-semaphore }</span>
        )

        <span class="cov7" title="3">return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov10" title="5">{
                select </span>{
                case semaphore &lt;- struct{}{}:<span class="cov8" title="4">
                        defer release()
                        next.ServeHTTP(w, r)</span>
                default:<span class="cov1" title="1">
                        w.WriteHeader(http.StatusServiceUnavailable)

                        if _, err := w.Write([]byte("Too many concurrent requests")); err != nil </span><span class="cov0" title="0">{
                                logger.Error("failed to write concurrency limit response",
                                        "error", err)
                        }</span>
                }
        })
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package middleware

import (
        "net/http"
        "sync"
        "time"
)

type TokenBucket struct {
        rate          int
        capacity      int
        tokens        int
        lastTimestamp time.Time
        mu            sync.Mutex
}

func NewTokenBucket(rate int) *TokenBucket <span class="cov4" title="4">{
        return &amp;TokenBucket{
                rate:          rate,
                capacity:      rate,
                tokens:        rate,
                lastTimestamp: time.Now(),
        }
}</span>

func (tb *TokenBucket) Wait() <span class="cov10" title="25">{
        tb.mu.Lock()
        defer tb.mu.Unlock()

        now := time.Now()
        elapsed := now.Sub(tb.lastTimestamp)
        tb.lastTimestamp = now

        newTokens := int(elapsed.Seconds() * float64(tb.rate))
        if newTokens &gt; 0 </span><span class="cov0" title="0">{
                tb.tokens = min(tb.tokens+newTokens, tb.capacity)
        }</span>

        <span class="cov10" title="25">if tb.tokens &gt; 0 </span><span class="cov9" title="22">{
                tb.tokens--
                return
        }</span>

        <span class="cov4" title="3">waitTime := time.Duration(float64(time.Second) / float64(tb.rate))
        time.Sleep(waitTime)
        tb.lastTimestamp = time.Now()</span>
}

func Rate(next http.HandlerFunc, rps int) http.HandlerFunc <span class="cov4" title="3">{
        limiter := NewTokenBucket(rps)

        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="14">{
                limiter.Wait()
                next(w, r)
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: api.go

// Package mock_rest is a generated GoMock package.
package mock_rest

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        core "yadro.com/course/api/core"
)

// MockAuthenticator is a mock of Authenticator interface.
type MockAuthenticator struct {
        ctrl     *gomock.Controller
        recorder *MockAuthenticatorMockRecorder
}

// MockAuthenticatorMockRecorder is the mock recorder for MockAuthenticator.
type MockAuthenticatorMockRecorder struct {
        mock *MockAuthenticator
}

// NewMockAuthenticator creates a new mock instance.
func NewMockAuthenticator(ctrl *gomock.Controller) *MockAuthenticator <span class="cov1" title="1">{
        mock := &amp;MockAuthenticator{ctrl: ctrl}
        mock.recorder = &amp;MockAuthenticatorMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAuthenticator) EXPECT() *MockAuthenticatorMockRecorder <span class="cov4" title="2">{
        return m.recorder
}</span>

// Login mocks base method.
func (m *MockAuthenticator) Login(user, password string) (string, error) <span class="cov4" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Login", user, password)
        ret0, _ := ret[0].(string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Login indicates an expected call of Login.
func (mr *MockAuthenticatorMockRecorder) Login(user, password interface{}) *gomock.Call <span class="cov4" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Login", reflect.TypeOf((*MockAuthenticator)(nil).Login), user, password)
}</span>

// MockNormalizer is a mock of Normalizer interface.
type MockNormalizer struct {
        ctrl     *gomock.Controller
        recorder *MockNormalizerMockRecorder
}

// MockNormalizerMockRecorder is the mock recorder for MockNormalizer.
type MockNormalizerMockRecorder struct {
        mock *MockNormalizer
}

// NewMockNormalizer creates a new mock instance.
func NewMockNormalizer(ctrl *gomock.Controller) *MockNormalizer <span class="cov1" title="1">{
        mock := &amp;MockNormalizer{ctrl: ctrl}
        mock.recorder = &amp;MockNormalizerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockNormalizer) EXPECT() *MockNormalizerMockRecorder <span class="cov6" title="3">{
        return m.recorder
}</span>

// Norm mocks base method.
func (m *MockNormalizer) Norm(arg0 context.Context, arg1 string) ([]string, error) <span class="cov6" title="3">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Norm", arg0, arg1)
        ret0, _ := ret[0].([]string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Norm indicates an expected call of Norm.
func (mr *MockNormalizerMockRecorder) Norm(arg0, arg1 interface{}) *gomock.Call <span class="cov6" title="3">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Norm", reflect.TypeOf((*MockNormalizer)(nil).Norm), arg0, arg1)
}</span>

// MockPinger is a mock of Pinger interface.
type MockPinger struct {
        ctrl     *gomock.Controller
        recorder *MockPingerMockRecorder
}

// MockPingerMockRecorder is the mock recorder for MockPinger.
type MockPingerMockRecorder struct {
        mock *MockPinger
}

// NewMockPinger creates a new mock instance.
func NewMockPinger(ctrl *gomock.Controller) *MockPinger <span class="cov7" title="4">{
        mock := &amp;MockPinger{ctrl: ctrl}
        mock.recorder = &amp;MockPingerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPinger) EXPECT() *MockPingerMockRecorder <span class="cov7" title="4">{
        return m.recorder
}</span>

// Ping mocks base method.
func (m *MockPinger) Ping(arg0 context.Context) error <span class="cov7" title="4">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Ping", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Ping indicates an expected call of Ping.
func (mr *MockPingerMockRecorder) Ping(arg0 interface{}) *gomock.Call <span class="cov7" title="4">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ping", reflect.TypeOf((*MockPinger)(nil).Ping), arg0)
}</span>

// MockUpdater is a mock of Updater interface.
type MockUpdater struct {
        ctrl     *gomock.Controller
        recorder *MockUpdaterMockRecorder
}

// MockUpdaterMockRecorder is the mock recorder for MockUpdater.
type MockUpdaterMockRecorder struct {
        mock *MockUpdater
}

// NewMockUpdater creates a new mock instance.
func NewMockUpdater(ctrl *gomock.Controller) *MockUpdater <span class="cov8" title="5">{
        mock := &amp;MockUpdater{ctrl: ctrl}
        mock.recorder = &amp;MockUpdaterMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUpdater) EXPECT() *MockUpdaterMockRecorder <span class="cov10" title="7">{
        return m.recorder
}</span>

// Drop mocks base method.
func (m *MockUpdater) Drop(arg0 context.Context) error <span class="cov4" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Drop", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Drop indicates an expected call of Drop.
func (mr *MockUpdaterMockRecorder) Drop(arg0 interface{}) *gomock.Call <span class="cov4" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Drop", reflect.TypeOf((*MockUpdater)(nil).Drop), arg0)
}</span>

// Stats mocks base method.
func (m *MockUpdater) Stats(arg0 context.Context) (core.UpdateStats, error) <span class="cov4" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Stats", arg0)
        ret0, _ := ret[0].(core.UpdateStats)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Stats indicates an expected call of Stats.
func (mr *MockUpdaterMockRecorder) Stats(arg0 interface{}) *gomock.Call <span class="cov4" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stats", reflect.TypeOf((*MockUpdater)(nil).Stats), arg0)
}</span>

// Status mocks base method.
func (m *MockUpdater) Status(arg0 context.Context) (core.UpdateStatus, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Status", arg0)
        ret0, _ := ret[0].(core.UpdateStatus)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Status indicates an expected call of Status.
func (mr *MockUpdaterMockRecorder) Status(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Status", reflect.TypeOf((*MockUpdater)(nil).Status), arg0)
}</span>

// Update mocks base method.
func (m *MockUpdater) Update(arg0 context.Context) error <span class="cov6" title="3">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Update indicates an expected call of Update.
func (mr *MockUpdaterMockRecorder) Update(arg0 interface{}) *gomock.Call <span class="cov6" title="3">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockUpdater)(nil).Update), arg0)
}</span>

// MockSearcher is a mock of Searcher interface.
type MockSearcher struct {
        ctrl     *gomock.Controller
        recorder *MockSearcherMockRecorder
}

// MockSearcherMockRecorder is the mock recorder for MockSearcher.
type MockSearcherMockRecorder struct {
        mock *MockSearcher
}

// NewMockSearcher creates a new mock instance.
func NewMockSearcher(ctrl *gomock.Controller) *MockSearcher <span class="cov4" title="2">{
        mock := &amp;MockSearcher{ctrl: ctrl}
        mock.recorder = &amp;MockSearcherMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSearcher) EXPECT() *MockSearcherMockRecorder <span class="cov9" title="6">{
        return m.recorder
}</span>

// IndexSearch mocks base method.
func (m *MockSearcher) IndexSearch(arg0 context.Context, arg1 string, arg2 int32) ([]core.Comics, int32, error) <span class="cov6" title="3">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "IndexSearch", arg0, arg1, arg2)
        ret0, _ := ret[0].([]core.Comics)
        ret1, _ := ret[1].(int32)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// IndexSearch indicates an expected call of IndexSearch.
func (mr *MockSearcherMockRecorder) IndexSearch(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov6" title="3">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IndexSearch", reflect.TypeOf((*MockSearcher)(nil).IndexSearch), arg0, arg1, arg2)
}</span>

// Search mocks base method.
func (m *MockSearcher) Search(arg0 context.Context, arg1 string, arg2 int32) ([]core.Comics, int32, error) <span class="cov6" title="3">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Search", arg0, arg1, arg2)
        ret0, _ := ret[0].([]core.Comics)
        ret1, _ := ret[1].(int32)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// Search indicates an expected call of Search.
func (mr *MockSearcherMockRecorder) Search(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov6" title="3">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Search", reflect.TypeOf((*MockSearcher)(nil).Search), arg0, arg1, arg2)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: proto/search/search_grpc.pb.go

// Package mock_search is a generated GoMock package.
package mock_search

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        grpc "google.golang.org/grpc"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
        search "yadro.com/course/proto/search"
)

// MockSearchClient is a mock of SearchClient interface.
type MockSearchClient struct {
        ctrl     *gomock.Controller
        recorder *MockSearchClientMockRecorder
}

// MockSearchClientMockRecorder is the mock recorder for MockSearchClient.
type MockSearchClientMockRecorder struct {
        mock *MockSearchClient
}

// NewMockSearchClient creates a new mock instance.
func NewMockSearchClient(ctrl *gomock.Controller) *MockSearchClient <span class="cov10" title="6">{
        mock := &amp;MockSearchClient{ctrl: ctrl}
        mock.recorder = &amp;MockSearchClientMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSearchClient) EXPECT() *MockSearchClientMockRecorder <span class="cov10" title="6">{
        return m.recorder
}</span>

// IndexSearch mocks base method.
func (m *MockSearchClient) IndexSearch(ctx context.Context, in *search.IndexSearchRequest, opts ...grpc.CallOption) (*search.SearchResponse, error) <span class="cov4" title="2">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov4" title="2">ret := m.ctrl.Call(m, "IndexSearch", varargs...)
        ret0, _ := ret[0].(*search.SearchResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// IndexSearch indicates an expected call of IndexSearch.
func (mr *MockSearchClientMockRecorder) IndexSearch(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov4" title="2">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IndexSearch", reflect.TypeOf((*MockSearchClient)(nil).IndexSearch), varargs...)
}</span>

// Ping mocks base method.
func (m *MockSearchClient) Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) <span class="cov4" title="2">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov4" title="2">ret := m.ctrl.Call(m, "Ping", varargs...)
        ret0, _ := ret[0].(*emptypb.Empty)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// Ping indicates an expected call of Ping.
func (mr *MockSearchClientMockRecorder) Ping(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov4" title="2">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ping", reflect.TypeOf((*MockSearchClient)(nil).Ping), varargs...)
}</span>

// Search mocks base method.
func (m *MockSearchClient) Search(ctx context.Context, in *search.SearchRequest, opts ...grpc.CallOption) (*search.SearchResponse, error) <span class="cov4" title="2">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov4" title="2">ret := m.ctrl.Call(m, "Search", varargs...)
        ret0, _ := ret[0].(*search.SearchResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// Search indicates an expected call of Search.
func (mr *MockSearchClientMockRecorder) Search(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov4" title="2">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Search", reflect.TypeOf((*MockSearchClient)(nil).Search), varargs...)
}</span>

// MockSearchServer is a mock of SearchServer interface.
type MockSearchServer struct {
        ctrl     *gomock.Controller
        recorder *MockSearchServerMockRecorder
}

// MockSearchServerMockRecorder is the mock recorder for MockSearchServer.
type MockSearchServerMockRecorder struct {
        mock *MockSearchServer
}

// NewMockSearchServer creates a new mock instance.
func NewMockSearchServer(ctrl *gomock.Controller) *MockSearchServer <span class="cov0" title="0">{
        mock := &amp;MockSearchServer{ctrl: ctrl}
        mock.recorder = &amp;MockSearchServerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSearchServer) EXPECT() *MockSearchServerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// IndexSearch mocks base method.
func (m *MockSearchServer) IndexSearch(arg0 context.Context, arg1 *search.IndexSearchRequest) (*search.SearchResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "IndexSearch", arg0, arg1)
        ret0, _ := ret[0].(*search.SearchResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// IndexSearch indicates an expected call of IndexSearch.
func (mr *MockSearchServerMockRecorder) IndexSearch(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IndexSearch", reflect.TypeOf((*MockSearchServer)(nil).IndexSearch), arg0, arg1)
}</span>

// Ping mocks base method.
func (m *MockSearchServer) Ping(arg0 context.Context, arg1 *emptypb.Empty) (*emptypb.Empty, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Ping", arg0, arg1)
        ret0, _ := ret[0].(*emptypb.Empty)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Ping indicates an expected call of Ping.
func (mr *MockSearchServerMockRecorder) Ping(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ping", reflect.TypeOf((*MockSearchServer)(nil).Ping), arg0, arg1)
}</span>

// Search mocks base method.
func (m *MockSearchServer) Search(arg0 context.Context, arg1 *search.SearchRequest) (*search.SearchResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Search", arg0, arg1)
        ret0, _ := ret[0].(*search.SearchResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Search indicates an expected call of Search.
func (mr *MockSearchServerMockRecorder) Search(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Search", reflect.TypeOf((*MockSearchServer)(nil).Search), arg0, arg1)
}</span>

// mustEmbedUnimplementedSearchServer mocks base method.
func (m *MockSearchServer) mustEmbedUnimplementedSearchServer() <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "mustEmbedUnimplementedSearchServer")
}</span>

// mustEmbedUnimplementedSearchServer indicates an expected call of mustEmbedUnimplementedSearchServer.
func (mr *MockSearchServerMockRecorder) mustEmbedUnimplementedSearchServer() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "mustEmbedUnimplementedSearchServer", reflect.TypeOf((*MockSearchServer)(nil).mustEmbedUnimplementedSearchServer))
}</span>

// MockUnsafeSearchServer is a mock of UnsafeSearchServer interface.
type MockUnsafeSearchServer struct {
        ctrl     *gomock.Controller
        recorder *MockUnsafeSearchServerMockRecorder
}

// MockUnsafeSearchServerMockRecorder is the mock recorder for MockUnsafeSearchServer.
type MockUnsafeSearchServerMockRecorder struct {
        mock *MockUnsafeSearchServer
}

// NewMockUnsafeSearchServer creates a new mock instance.
func NewMockUnsafeSearchServer(ctrl *gomock.Controller) *MockUnsafeSearchServer <span class="cov0" title="0">{
        mock := &amp;MockUnsafeSearchServer{ctrl: ctrl}
        mock.recorder = &amp;MockUnsafeSearchServerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUnsafeSearchServer) EXPECT() *MockUnsafeSearchServerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// mustEmbedUnimplementedSearchServer mocks base method.
func (m *MockUnsafeSearchServer) mustEmbedUnimplementedSearchServer() <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "mustEmbedUnimplementedSearchServer")
}</span>

// mustEmbedUnimplementedSearchServer indicates an expected call of mustEmbedUnimplementedSearchServer.
func (mr *MockUnsafeSearchServerMockRecorder) mustEmbedUnimplementedSearchServer() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "mustEmbedUnimplementedSearchServer", reflect.TypeOf((*MockUnsafeSearchServer)(nil).mustEmbedUnimplementedSearchServer))
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package search

import (
        "context"
        "log/slog"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/credentials/insecure"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/emptypb"

        "yadro.com/course/api/core"
        searchpb "yadro.com/course/proto/search"
)

type Client struct {
        log    *slog.Logger
        client searchpb.SearchClient
}

func NewClient(address string, log *slog.Logger) (*Client, error) <span class="cov0" title="0">{
        conn, err := grpc.NewClient(address, grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                log.Error("failed to connect to search service", "error", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;Client{
                client: searchpb.NewSearchClient(conn),
                log:    log,
        }, nil</span>
}

func (c Client) Ping(ctx context.Context) error <span class="cov10" title="2">{
        c.log.Debug("calling Ping")
        _, err := c.client.Ping(ctx, &amp;emptypb.Empty{})
        if err != nil </span><span class="cov1" title="1">{
                c.log.Error("error calling Ping", "error", err)
                return err
        }</span>
        <span class="cov1" title="1">c.log.Debug("successfully pinged search")
        return nil</span>
}

func (c Client) Search(ctx context.Context, phrase string, limit int32) ([]core.Comics, int32, error) <span class="cov10" title="2">{
        c.log.Debug("calling Search", "phrase", phrase, "limit", limit)
        resp, err := c.client.Search(ctx, &amp;searchpb.SearchRequest{
                Phrase: phrase,
                Limit:  limit,
        })
        if err != nil </span><span class="cov1" title="1">{
                if status.Code(err) == codes.InvalidArgument </span><span class="cov1" title="1">{
                        c.log.Warn("invalid argument", "error", err)
                        return nil, 0, core.ErrBadArguments
                }</span>
                <span class="cov0" title="0">c.log.Error("error calling Search", "error", err)
                return nil, 0, err</span>
        }

        <span class="cov1" title="1">var comics []core.Comics
        for _, comic := range resp.Comics </span><span class="cov10" title="2">{
                comics = append(comics, core.Comics{
                        ID:  int(comic.Id),
                        URL: comic.Url,
                })
        }</span>

        <span class="cov1" title="1">c.log.Debug("successfully searched comics", "total", resp.Total)
        return comics, resp.Total, nil</span>
}

func (c Client) IndexSearch(ctx context.Context, phrase string, limit int32) ([]core.Comics, int32, error) <span class="cov10" title="2">{
        c.log.Debug("calling IndexSearch", "phrase", phrase, "limit", limit)

        resp, err := c.client.IndexSearch(ctx, &amp;searchpb.IndexSearchRequest{
                Phrase: phrase,
                Limit:  limit,
        })
        if err != nil </span><span class="cov1" title="1">{
                if status.Code(err) == codes.InvalidArgument </span><span class="cov0" title="0">{
                        c.log.Warn("invalid argument in IndexSearch", "error", err)
                        return nil, 0, core.ErrBadArguments
                }</span>
                <span class="cov1" title="1">c.log.Error("error calling IndexSearch", "error", err)
                return nil, 0, err</span>
        }

        <span class="cov1" title="1">var comics []core.Comics
        for _, comic := range resp.Comics </span><span class="cov1" title="1">{
                comics = append(comics, core.Comics{
                        ID:  int(comic.Id),
                        URL: comic.Url,
                })
        }</span>

        <span class="cov1" title="1">c.log.Debug("successfully searched comics via index", "total", resp.Total)
        return comics, resp.Total, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: proto/update/update_grpc.pb.go

// Package mock_update is a generated GoMock package.
package mock_update

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        grpc "google.golang.org/grpc"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
        update "yadro.com/course/proto/update"
)

// MockUpdateClient is a mock of UpdateClient interface.
type MockUpdateClient struct {
        ctrl     *gomock.Controller
        recorder *MockUpdateClientMockRecorder
}

// MockUpdateClientMockRecorder is the mock recorder for MockUpdateClient.
type MockUpdateClientMockRecorder struct {
        mock *MockUpdateClient
}

// NewMockUpdateClient creates a new mock instance.
func NewMockUpdateClient(ctrl *gomock.Controller) *MockUpdateClient <span class="cov10" title="12">{
        mock := &amp;MockUpdateClient{ctrl: ctrl}
        mock.recorder = &amp;MockUpdateClientMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUpdateClient) EXPECT() *MockUpdateClientMockRecorder <span class="cov10" title="12">{
        return m.recorder
}</span>

// Drop mocks base method.
func (m *MockUpdateClient) Drop(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) <span class="cov3" title="2">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov3" title="2">ret := m.ctrl.Call(m, "Drop", varargs...)
        ret0, _ := ret[0].(*emptypb.Empty)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// Drop indicates an expected call of Drop.
func (mr *MockUpdateClientMockRecorder) Drop(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov3" title="2">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Drop", reflect.TypeOf((*MockUpdateClient)(nil).Drop), varargs...)
}</span>

// Ping mocks base method.
func (m *MockUpdateClient) Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) <span class="cov3" title="2">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov3" title="2">ret := m.ctrl.Call(m, "Ping", varargs...)
        ret0, _ := ret[0].(*emptypb.Empty)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// Ping indicates an expected call of Ping.
func (mr *MockUpdateClientMockRecorder) Ping(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov3" title="2">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ping", reflect.TypeOf((*MockUpdateClient)(nil).Ping), varargs...)
}</span>

// Stats mocks base method.
func (m *MockUpdateClient) Stats(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*update.StatsReply, error) <span class="cov3" title="2">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov3" title="2">ret := m.ctrl.Call(m, "Stats", varargs...)
        ret0, _ := ret[0].(*update.StatsReply)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// Stats indicates an expected call of Stats.
func (mr *MockUpdateClientMockRecorder) Stats(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov3" title="2">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stats", reflect.TypeOf((*MockUpdateClient)(nil).Stats), varargs...)
}</span>

// Status mocks base method.
func (m *MockUpdateClient) Status(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*update.StatusReply, error) <span class="cov6" title="4">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov6" title="4">ret := m.ctrl.Call(m, "Status", varargs...)
        ret0, _ := ret[0].(*update.StatusReply)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// Status indicates an expected call of Status.
func (mr *MockUpdateClientMockRecorder) Status(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov6" title="4">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Status", reflect.TypeOf((*MockUpdateClient)(nil).Status), varargs...)
}</span>

// Update mocks base method.
func (m *MockUpdateClient) Update(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) <span class="cov3" title="2">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov3" title="2">ret := m.ctrl.Call(m, "Update", varargs...)
        ret0, _ := ret[0].(*emptypb.Empty)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// Update indicates an expected call of Update.
func (mr *MockUpdateClientMockRecorder) Update(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov3" title="2">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockUpdateClient)(nil).Update), varargs...)
}</span>

// MockUpdateServer is a mock of UpdateServer interface.
type MockUpdateServer struct {
        ctrl     *gomock.Controller
        recorder *MockUpdateServerMockRecorder
}

// MockUpdateServerMockRecorder is the mock recorder for MockUpdateServer.
type MockUpdateServerMockRecorder struct {
        mock *MockUpdateServer
}

// NewMockUpdateServer creates a new mock instance.
func NewMockUpdateServer(ctrl *gomock.Controller) *MockUpdateServer <span class="cov0" title="0">{
        mock := &amp;MockUpdateServer{ctrl: ctrl}
        mock.recorder = &amp;MockUpdateServerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUpdateServer) EXPECT() *MockUpdateServerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Drop mocks base method.
func (m *MockUpdateServer) Drop(arg0 context.Context, arg1 *emptypb.Empty) (*emptypb.Empty, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Drop", arg0, arg1)
        ret0, _ := ret[0].(*emptypb.Empty)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Drop indicates an expected call of Drop.
func (mr *MockUpdateServerMockRecorder) Drop(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Drop", reflect.TypeOf((*MockUpdateServer)(nil).Drop), arg0, arg1)
}</span>

// Ping mocks base method.
func (m *MockUpdateServer) Ping(arg0 context.Context, arg1 *emptypb.Empty) (*emptypb.Empty, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Ping", arg0, arg1)
        ret0, _ := ret[0].(*emptypb.Empty)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Ping indicates an expected call of Ping.
func (mr *MockUpdateServerMockRecorder) Ping(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ping", reflect.TypeOf((*MockUpdateServer)(nil).Ping), arg0, arg1)
}</span>

// Stats mocks base method.
func (m *MockUpdateServer) Stats(arg0 context.Context, arg1 *emptypb.Empty) (*update.StatsReply, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Stats", arg0, arg1)
        ret0, _ := ret[0].(*update.StatsReply)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Stats indicates an expected call of Stats.
func (mr *MockUpdateServerMockRecorder) Stats(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stats", reflect.TypeOf((*MockUpdateServer)(nil).Stats), arg0, arg1)
}</span>

// Status mocks base method.
func (m *MockUpdateServer) Status(arg0 context.Context, arg1 *emptypb.Empty) (*update.StatusReply, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Status", arg0, arg1)
        ret0, _ := ret[0].(*update.StatusReply)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Status indicates an expected call of Status.
func (mr *MockUpdateServerMockRecorder) Status(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Status", reflect.TypeOf((*MockUpdateServer)(nil).Status), arg0, arg1)
}</span>

// Update mocks base method.
func (m *MockUpdateServer) Update(arg0 context.Context, arg1 *emptypb.Empty) (*emptypb.Empty, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", arg0, arg1)
        ret0, _ := ret[0].(*emptypb.Empty)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Update indicates an expected call of Update.
func (mr *MockUpdateServerMockRecorder) Update(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockUpdateServer)(nil).Update), arg0, arg1)
}</span>

// mustEmbedUnimplementedUpdateServer mocks base method.
func (m *MockUpdateServer) mustEmbedUnimplementedUpdateServer() <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "mustEmbedUnimplementedUpdateServer")
}</span>

// mustEmbedUnimplementedUpdateServer indicates an expected call of mustEmbedUnimplementedUpdateServer.
func (mr *MockUpdateServerMockRecorder) mustEmbedUnimplementedUpdateServer() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "mustEmbedUnimplementedUpdateServer", reflect.TypeOf((*MockUpdateServer)(nil).mustEmbedUnimplementedUpdateServer))
}</span>

// MockUnsafeUpdateServer is a mock of UnsafeUpdateServer interface.
type MockUnsafeUpdateServer struct {
        ctrl     *gomock.Controller
        recorder *MockUnsafeUpdateServerMockRecorder
}

// MockUnsafeUpdateServerMockRecorder is the mock recorder for MockUnsafeUpdateServer.
type MockUnsafeUpdateServerMockRecorder struct {
        mock *MockUnsafeUpdateServer
}

// NewMockUnsafeUpdateServer creates a new mock instance.
func NewMockUnsafeUpdateServer(ctrl *gomock.Controller) *MockUnsafeUpdateServer <span class="cov0" title="0">{
        mock := &amp;MockUnsafeUpdateServer{ctrl: ctrl}
        mock.recorder = &amp;MockUnsafeUpdateServerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUnsafeUpdateServer) EXPECT() *MockUnsafeUpdateServerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// mustEmbedUnimplementedUpdateServer mocks base method.
func (m *MockUnsafeUpdateServer) mustEmbedUnimplementedUpdateServer() <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "mustEmbedUnimplementedUpdateServer")
}</span>

// mustEmbedUnimplementedUpdateServer indicates an expected call of mustEmbedUnimplementedUpdateServer.
func (mr *MockUnsafeUpdateServerMockRecorder) mustEmbedUnimplementedUpdateServer() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "mustEmbedUnimplementedUpdateServer", reflect.TypeOf((*MockUnsafeUpdateServer)(nil).mustEmbedUnimplementedUpdateServer))
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package update

import (
        "context"
        "fmt"
        "log/slog"

        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
        "google.golang.org/protobuf/types/known/emptypb"

        "yadro.com/course/api/core"
        updatepb "yadro.com/course/proto/update"
)

type Client struct {
        log    *slog.Logger
        client updatepb.UpdateClient
}

func NewClient(address string, log *slog.Logger) (*Client, error) <span class="cov0" title="0">{
        conn, err := grpc.NewClient(address, grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;Client{
                client: updatepb.NewUpdateClient(conn),
                log:    log,
        }, nil</span>
}

func (c Client) Ping(ctx context.Context) error <span class="cov5" title="2">{
        _, err := c.client.Ping(ctx, &amp;emptypb.Empty{})
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to ping update service: %w", err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func (c Client) Status(ctx context.Context) (core.UpdateStatus, error) <span class="cov10" title="4">{
        resp, err := c.client.Status(ctx, &amp;emptypb.Empty{})
        if err != nil </span><span class="cov1" title="1">{
                return core.StatusUpdateUnknown, fmt.Errorf("failed to get status: %w", err)
        }</span>
        <span class="cov8" title="3">var status core.UpdateStatus
        switch resp.Status </span>{
        case updatepb.Status_STATUS_IDLE:<span class="cov1" title="1">
                status = core.StatusUpdateIdle</span>
        case updatepb.Status_STATUS_RUNNING:<span class="cov1" title="1">
                status = core.StatusUpdateRunning</span>
        default:<span class="cov1" title="1">
                status = core.StatusUpdateUnknown</span>
        }

        <span class="cov8" title="3">return status, nil</span>
}

func (c Client) Stats(ctx context.Context) (core.UpdateStats, error) <span class="cov5" title="2">{
        resp, err := c.client.Stats(ctx, &amp;emptypb.Empty{})
        if err != nil </span><span class="cov1" title="1">{
                return core.UpdateStats{}, fmt.Errorf("failed to get stats: %w", err)
        }</span>
        <span class="cov1" title="1">return core.UpdateStats{
                WordsTotal:    int(resp.WordsTotal),
                WordsUnique:   int(resp.WordsUnique),
                ComicsFetched: int(resp.ComicsFetched),
                ComicsTotal:   int(resp.ComicsTotal),
        }, nil</span>
}

func (c Client) Update(ctx context.Context) error <span class="cov5" title="2">{
        _, err := c.client.Update(ctx, &amp;emptypb.Empty{})
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to update: %w", err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func (c Client) Drop(ctx context.Context) error <span class="cov5" title="2">{
        _, err := c.client.Drop(ctx, &amp;emptypb.Empty{})
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to drop database: %w", err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: proto/words/words_grpc.pb.go

// Package mock_words is a generated GoMock package.
package mock_words

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        grpc "google.golang.org/grpc"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
        words "yadro.com/course/proto/words"
)

// MockWordsClient is a mock of WordsClient interface.
type MockWordsClient struct {
        ctrl     *gomock.Controller
        recorder *MockWordsClientMockRecorder
}

// MockWordsClientMockRecorder is the mock recorder for MockWordsClient.
type MockWordsClientMockRecorder struct {
        mock *MockWordsClient
}

// NewMockWordsClient creates a new mock instance.
func NewMockWordsClient(ctrl *gomock.Controller) *MockWordsClient <span class="cov10" title="10">{
        mock := &amp;MockWordsClient{ctrl: ctrl}
        mock.recorder = &amp;MockWordsClientMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWordsClient) EXPECT() *MockWordsClientMockRecorder <span class="cov10" title="10">{
        return m.recorder
}</span>

// Norm mocks base method.
func (m *MockWordsClient) Norm(ctx context.Context, in *words.WordsRequest, opts ...grpc.CallOption) (*words.WordsReply, error) <span class="cov8" title="6">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="6">ret := m.ctrl.Call(m, "Norm", varargs...)
        ret0, _ := ret[0].(*words.WordsReply)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// Norm indicates an expected call of Norm.
func (mr *MockWordsClientMockRecorder) Norm(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov8" title="6">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Norm", reflect.TypeOf((*MockWordsClient)(nil).Norm), varargs...)
}</span>

// Ping mocks base method.
func (m *MockWordsClient) Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) <span class="cov6" title="4">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov6" title="4">ret := m.ctrl.Call(m, "Ping", varargs...)
        ret0, _ := ret[0].(*emptypb.Empty)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// Ping indicates an expected call of Ping.
func (mr *MockWordsClientMockRecorder) Ping(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov6" title="4">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ping", reflect.TypeOf((*MockWordsClient)(nil).Ping), varargs...)
}</span>

// MockWordsServer is a mock of WordsServer interface.
type MockWordsServer struct {
        ctrl     *gomock.Controller
        recorder *MockWordsServerMockRecorder
}

// MockWordsServerMockRecorder is the mock recorder for MockWordsServer.
type MockWordsServerMockRecorder struct {
        mock *MockWordsServer
}

// NewMockWordsServer creates a new mock instance.
func NewMockWordsServer(ctrl *gomock.Controller) *MockWordsServer <span class="cov0" title="0">{
        mock := &amp;MockWordsServer{ctrl: ctrl}
        mock.recorder = &amp;MockWordsServerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWordsServer) EXPECT() *MockWordsServerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Norm mocks base method.
func (m *MockWordsServer) Norm(arg0 context.Context, arg1 *words.WordsRequest) (*words.WordsReply, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Norm", arg0, arg1)
        ret0, _ := ret[0].(*words.WordsReply)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Norm indicates an expected call of Norm.
func (mr *MockWordsServerMockRecorder) Norm(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Norm", reflect.TypeOf((*MockWordsServer)(nil).Norm), arg0, arg1)
}</span>

// Ping mocks base method.
func (m *MockWordsServer) Ping(arg0 context.Context, arg1 *emptypb.Empty) (*emptypb.Empty, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Ping", arg0, arg1)
        ret0, _ := ret[0].(*emptypb.Empty)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Ping indicates an expected call of Ping.
func (mr *MockWordsServerMockRecorder) Ping(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ping", reflect.TypeOf((*MockWordsServer)(nil).Ping), arg0, arg1)
}</span>

// mustEmbedUnimplementedWordsServer mocks base method.
func (m *MockWordsServer) mustEmbedUnimplementedWordsServer() <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "mustEmbedUnimplementedWordsServer")
}</span>

// mustEmbedUnimplementedWordsServer indicates an expected call of mustEmbedUnimplementedWordsServer.
func (mr *MockWordsServerMockRecorder) mustEmbedUnimplementedWordsServer() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "mustEmbedUnimplementedWordsServer", reflect.TypeOf((*MockWordsServer)(nil).mustEmbedUnimplementedWordsServer))
}</span>

// MockUnsafeWordsServer is a mock of UnsafeWordsServer interface.
type MockUnsafeWordsServer struct {
        ctrl     *gomock.Controller
        recorder *MockUnsafeWordsServerMockRecorder
}

// MockUnsafeWordsServerMockRecorder is the mock recorder for MockUnsafeWordsServer.
type MockUnsafeWordsServerMockRecorder struct {
        mock *MockUnsafeWordsServer
}

// NewMockUnsafeWordsServer creates a new mock instance.
func NewMockUnsafeWordsServer(ctrl *gomock.Controller) *MockUnsafeWordsServer <span class="cov0" title="0">{
        mock := &amp;MockUnsafeWordsServer{ctrl: ctrl}
        mock.recorder = &amp;MockUnsafeWordsServerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUnsafeWordsServer) EXPECT() *MockUnsafeWordsServerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// mustEmbedUnimplementedWordsServer mocks base method.
func (m *MockUnsafeWordsServer) mustEmbedUnimplementedWordsServer() <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "mustEmbedUnimplementedWordsServer")
}</span>

// mustEmbedUnimplementedWordsServer indicates an expected call of mustEmbedUnimplementedWordsServer.
func (mr *MockUnsafeWordsServerMockRecorder) mustEmbedUnimplementedWordsServer() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "mustEmbedUnimplementedWordsServer", reflect.TypeOf((*MockUnsafeWordsServer)(nil).mustEmbedUnimplementedWordsServer))
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package words

import (
        "context"
        "log/slog"

        "google.golang.org/grpc/credentials/insecure"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/emptypb"
        "yadro.com/course/api/core"
        wordspb "yadro.com/course/proto/words"
)

type Client struct {
        Log    *slog.Logger
        Client wordspb.WordsClient
}

func NewClient(address string, log *slog.Logger) (*Client, error) <span class="cov1" title="1">{
        connection, err := grpc.NewClient(address, grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                log.Error("failed to connect to server", "error", err)
                return nil, err
        }</span>

        <span class="cov1" title="1">return &amp;Client{
                Log:    log,
                Client: wordspb.NewWordsClient(connection),
        }, nil</span>
}

func (c Client) Norm(ctx context.Context, phrase string) ([]string, error) <span class="cov10" title="3">{
        c.Log.Debug("calling Norm", "phrase", phrase)
        resp, err := c.Client.Norm(ctx, &amp;wordspb.WordsRequest{Phrase: phrase})
        if err != nil </span><span class="cov6" title="2">{
                if status.Code(err) == codes.ResourceExhausted </span><span class="cov1" title="1">{
                        c.Log.Warn("resource exhausted", "error", err)
                        return nil, core.ErrBadArguments
                }</span>
                <span class="cov1" title="1">c.Log.Error("error calling Norm", "error", err)
                return nil, err</span>
        }
        <span class="cov1" title="1">c.Log.Debug("successfully normalized phrase", "words", resp.Words)
        return resp.Words, nil</span>
}

func (c Client) Ping(ctx context.Context) error <span class="cov6" title="2">{
        c.Log.Debug("calling Ping")
        _, err := c.Client.Ping(ctx, &amp;emptypb.Empty{})
        if err != nil </span><span class="cov1" title="1">{
                c.Log.Error("error calling Ping", "error", err)
                return err
        }</span>
        <span class="cov1" title="1">c.Log.Debug("successfully pinged words")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package yolo

import (
        "context"
        "log/slog"

        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
        "yadro.com/course/api/core"
        yolopb "yadro.com/course/proto/yolo"
)

type Client struct {
        client yolopb.YoloServiceClient
        conn   *grpc.ClientConn
        log    *slog.Logger
}

func NewClient(address string, log *slog.Logger) (*Client, error) <span class="cov0" title="0">{
        conn, err := grpc.Dial(address, grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                log.Error("failed to connect to yolo service", "error", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;Client{
                client: yolopb.NewYoloServiceClient(conn),
                conn:   conn,
                log:    log,
        }, nil</span>
}

func (c *Client) Close() error <span class="cov0" title="0">{
        return c.conn.Close()
}</span>

func (c *Client) Detect(ctx context.Context, imageData []byte) ([]core.Yolo, error) <span class="cov0" title="0">{
        resp, err := c.client.Detect(ctx, &amp;yolopb.DetectRequest{
                ImageData: imageData,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">results := make([]core.Yolo, len(resp.Results))
        for i, r := range resp.Results </span><span class="cov0" title="0">{
                results[i] = core.Yolo{
                        BBox:       r.Bbox,
                        Confidence: r.Confidence,
                        Label:      r.Label,
                        LabelNum:   int(r.LabelNum),
                }
        }</span>
        <span class="cov0" title="0">return results, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package config

import (
        "log"
        "time"

        "github.com/ilyakaznacheev/cleanenv"
)

type HTTPConfig struct {
        Address string        `yaml:"address" env:"API_ADDRESS" env-default:"localhost:80"`
        Timeout time.Duration `yaml:"timeout" env:"API_TIMEOUT" env-default:"5s"`
}

type Config struct {
        LogLevel          string        `yaml:"log_level" env:"LOG_LEVEL" env-default:"DEBUG"`
        SearchConcurrency int           `yaml:"search_concurrency" env:"SEARCH_CONCURRENCY" env-default:"1"`
        SearchRate        int           `yaml:"search_rate" env:"SEARCH_RATE" env-default:"1"`
        HTTPConfig        HTTPConfig    `yaml:"api_server"`
        WordsAddress      string        `yaml:"words_address" env:"WORDS_ADDRESS" env-default:"words:81"`
        UpdateAddress     string        `yaml:"update_address" env:"UPDATE_ADDRESS" env-default:"update:82"`
        SearchAddress     string        `yaml:"search_address" env:"SEARCH_ADDRESS" env-default:"search:83"`
        TokenTTL          time.Duration `yaml:"token_ttl" env:"TOKEN_TTL" env-default:"24h"`
        YoloAddress       string        `yaml:"yolo_address" env:"YOLO_ADDRESS"`
}

func MustLoad(configPath string) Config <span class="cov10" title="3">{
        var cfg Config
        if err := cleanenv.ReadConfig(configPath, &amp;cfg); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("cannot read config %q: %s", configPath, err)
        }</span>
        <span class="cov10" title="3">return cfg</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package main

import (
        "context"
        "errors"
        "flag"
        "log/slog"
        "net/http"
        "os"
        "os/signal"
        "strconv"
        "time"
        "yadro.com/course/api/adapters/aaa"
        "yadro.com/course/api/adapters/rest/middleware"
        "yadro.com/course/api/adapters/yolo"

        "yadro.com/course/api/adapters/search"

        "yadro.com/course/api/adapters/words"
        "yadro.com/course/api/core"

        "yadro.com/course/api/adapters/rest"
        "yadro.com/course/api/adapters/update"
        "yadro.com/course/api/config"
)

func main() <span class="cov0" title="0">{
        var configPath string
        flag.StringVar(&amp;configPath, "config", "config.yaml", "server configuration file")
        flag.Parse()

        cfg := config.MustLoad(configPath)

        log := mustMakeLogger(cfg.LogLevel)

        log.Info("starting server")
        log.Debug("debug messages are enabled")

        tokenTTL := 2 * time.Minute
        if ttl := os.Getenv("TOKEN_TTL"); ttl != "" </span><span class="cov0" title="0">{
                if parsed, err := time.ParseDuration(ttl); err == nil </span><span class="cov0" title="0">{
                        tokenTTL = parsed
                }</span>
        }

        <span class="cov0" title="0">aaaService, err := aaa.New(tokenTTL, log)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("cannot init AAA service", "error", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">concurrencyLimit, _ := strconv.Atoi(os.Getenv("SEARCH_CONCURRENCY"))
        rateLimit, _ := strconv.Atoi(os.Getenv("SEARCH_RATE"))

        updateClient, err := update.NewClient(cfg.UpdateAddress, log)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("cannot init update adapter", "error", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">wordsClient, err := words.NewClient(cfg.WordsAddress, log)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("cannot init words adapter", "error", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">searchClient, err := search.NewClient(cfg.SearchAddress, log)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("cannot init search adapter", "error", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">yoloClient, err := yolo.NewClient(cfg.YoloAddress, log)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("failed to create yolo client", "error", err)
                return
        }</span>

        <span class="cov0" title="0">mux := http.NewServeMux()
        mux.Handle("POST  /api/detect", rest.NewDetectHandler(log, yoloClient, searchClient))

        mux.Handle("POST /api/login", rest.NewLoginHandler(log, aaaService))
        mux.Handle("GET /api/db/stats", rest.NewUpdateStatsHandler(log, updateClient))
        mux.Handle("GET /api/db/status", rest.NewUpdateStatusHandler(log, updateClient))
        mux.Handle("GET /api/words", rest.NewWordsHandler(log, wordsClient))
        mux.Handle("GET /api/ping", rest.NewPingHandler(log, map[string]core.Pinger{"words": wordsClient, "update": updateClient, "search": searchClient}))

        mux.Handle("POST /api/db/update", middleware.Auth(
                rest.NewUpdateHandler(log, updateClient),
                aaaService,
        ))

        mux.Handle("DELETE /api/db", middleware.Auth(
                rest.NewDropHandler(log, updateClient),
                aaaService,
        ))

        mux.Handle("GET /api/search", middleware.Concurrency(
                rest.NewSearchHandler(log, searchClient),
                concurrencyLimit,
        ))

        mux.Handle("GET /api/isearch", middleware.Rate(
                rest.NewSearchIndexHandler(log, searchClient),
                rateLimit,
        ))
        server := http.Server{
                Addr:        cfg.HTTPConfig.Address,
                ReadTimeout: cfg.HTTPConfig.Timeout,
                Handler:     mux,
        }

        ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt)
        defer stop()

        go func() </span><span class="cov0" title="0">{
                &lt;-ctx.Done()
                log.Debug("shutting down server")
                if err := server.Shutdown(context.Background()); err != nil </span><span class="cov0" title="0">{
                        log.Error("erroneous shutdown", "error", err)
                }</span>
        }()

        <span class="cov0" title="0">log.Info("Running HTTP server", "address", cfg.HTTPConfig.Address)
        if err := server.ListenAndServe(); err != nil </span><span class="cov0" title="0">{
                if !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                        log.Error("server closed unexpectedly", "error", err)
                        return
                }</span>
        }
}

func mustMakeLogger(logLevel string) *slog.Logger <span class="cov0" title="0">{
        var level slog.Level
        switch logLevel </span>{
        case "DEBUG":<span class="cov0" title="0">
                level = slog.LevelDebug</span>
        case "INFO":<span class="cov0" title="0">
                level = slog.LevelInfo</span>
        case "ERROR":<span class="cov0" title="0">
                level = slog.LevelError</span>
        default:<span class="cov0" title="0">
                panic("unknown log level: " + logLevel)</span>
        }
        <span class="cov0" title="0">handler := slog.NewTextHandler(os.Stderr, &amp;slog.HandlerOptions{Level: level, AddSource: true})
        return slog.New(handler)</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package config

import (
        "log"
        "time"

        "github.com/ilyakaznacheev/cleanenv"
)

type Server struct {
        Address string        `yaml:"address" env:"HTTP_ADDRESS" env-default:"http_server:84"`
        Timeout time.Duration `yaml:"timeout" env:"HTTP_TIMEOUT" env-default:"5s"`
}

type API struct {
        ApiURL string `yaml:"url" env:"API_BASE_URL" env-default:"localhost:28080"`
}

type Config struct {
        LogLevel string `yaml:"log_level" env:"LOG_LEVEL" env-default:"INFO"`
        Server   Server `yaml:"server"`
        API      API    `yaml:"api"`
}

func MustLoad(path string) *Config <span class="cov0" title="0">{
        var cfg Config

        if err := cleanenv.ReadConfig(path, &amp;cfg); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("cannot read config: %v", err)
        }</span>
        <span class="cov0" title="0">return &amp;cfg</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package handlers

import (
        "bytes"
        "encoding/json"
        "fmt"
        "html/template"
        "io"
        "log/slog"
        "mime/multipart"
        "net/http"
        "net/url"
        "time"
)

type Comic struct {
        ID    int    `json:"id"`
        URL   string `json:"url"`
        Score int    `json:"score"`
}

type UpdateStats struct {
        WordsTotal    int `json:"words_total"`
        WordsUnique   int `json:"words_unique"`
        ComicsFetched int `json:"comics_fetched"`
        ComicsTotal   int `json:"comics_total"`
}

type UpdateStatus struct {
        Status string `json:"status"`
}

type Handler struct {
        log       *slog.Logger
        client    *http.Client
        apiURL    string
        templates *template.Template
}

func NewHandler(log *slog.Logger, client *http.Client, apiURL string) *Handler <span class="cov0" title="0">{
        tmpl := template.Must(template.ParseGlob("templates/*.html"))
        return &amp;Handler{
                log:       log,
                client:    client,
                apiURL:    apiURL,
                templates: tmpl,
        }
}</span>

func (h *Handler) Index(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        data := struct {
                SearchQuery string
                FastSearch  bool
        }{
                SearchQuery: r.URL.Query().Get("q"),
                FastSearch:  r.URL.Query().Get("fast") == "on",
        }

        if err := h.templates.ExecuteTemplate(w, "index.html", data); err != nil </span><span class="cov0" title="0">{
                h.log.Error("failed to render index", "error", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
        }</span>
}

func (h *Handler) ImageSearch(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        data := struct {
                PageTitle string
        }{
                PageTitle: "Search by Image",
        }

        if err := h.templates.ExecuteTemplate(w, "image_search.html", data); err != nil </span><span class="cov0" title="0">{
                h.log.Error("failed to render image search page", "error", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
        }</span>
}

func (h *Handler) Detect(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        startTime := time.Now()
        if err := r.ParseMultipartForm(10 &lt;&lt; 20); err != nil </span><span class="cov0" title="0">{
                h.log.Error("failed to parse multipart form", "error", err)
                http.Error(w, "File too large", http.StatusBadRequest)
                return
        }</span>

        // Получаем файл из запроса
        <span class="cov0" title="0">file, header, err := r.FormFile("image")
        if err != nil </span><span class="cov0" title="0">{
                h.log.Error("failed to get image from request", "error", err)
                http.Error(w, "Bad request: no image provided", http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // Создаем новый multipart/form-data запрос
        body := &amp;bytes.Buffer{}
        writer := multipart.NewWriter(body)
        part, err := writer.CreateFormFile("image", header.Filename)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Error("failed to create form file", "error", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>

        // Копируем содержимое файла
        <span class="cov0" title="0">if _, err := io.Copy(part, file); err != nil </span><span class="cov0" title="0">{
                h.log.Error("failed to copy file content", "error", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">writer.Close()

        // Создаем новый запрос к API сервису
        apiURL := h.apiURL + "/api/detect"
        req, err := http.NewRequest("POST", apiURL, body)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Error("failed to create API request", "error", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>

        // Устанавливаем правильный Content-Type
        <span class="cov0" title="0">req.Header.Set("Content-Type", writer.FormDataContentType())

        // Отправляем запрос к API
        resp, err := h.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Error("detect API call failed", "error", err)
                http.Error(w, "Detection service unavailable", http.StatusServiceUnavailable)
                return
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // Проверяем статус ответа
        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                h.log.Error("detection failed", "status", resp.Status, "body", string(body))
                http.Error(w, "Detection failed", http.StatusInternalServerError)
                return
        }</span>

        // Парсим ответ от API
        <span class="cov0" title="0">var result struct {
                Comics []struct {
                        ID    int     `json:"id"`
                        URL   string  `json:"url"`
                        Score float64 `json:"score"`
                } `json:"comics"`
                Total int `json:"total"`
        }

        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                h.log.Error("failed to decode detection results", "error", err)
                http.Error(w, "Invalid response format", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">searchTime := time.Since(startTime)
        // Подготавливаем данные для шаблона
        data := struct {
                Phrase         string
                IsImageResults bool
                Total          int
                Comics         []Comic
                SearchTime     string
                Limit          string
                Fast           bool // Добавьте, если используется в шаблоне
        }{
                Phrase:         "Image search",
                IsImageResults: true,
                Total:          result.Total,
                Comics:         make([]Comic, len(result.Comics)),
                SearchTime:     fmt.Sprintf("%.2fms", float64(searchTime.Microseconds())/1000),
                Limit:          "10",
                Fast:           false,
        }

        for i, c := range result.Comics </span><span class="cov0" title="0">{
                data.Comics[i] = Comic{
                        ID:    c.ID,
                        URL:   c.URL,
                        Score: int(c.Score * 100),
                }
        }</span>

        <span class="cov0" title="0">if err := h.templates.ExecuteTemplate(w, "results.html", data); err != nil </span><span class="cov0" title="0">{
                h.log.Error("failed to render results", "error", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
        }</span>
}

func (h *Handler) Search(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        startTime := time.Now()

        query := r.URL.Query().Get("phrase")
        if query == "" </span><span class="cov0" title="0">{
                query = r.URL.Query().Get("q")
                if query == "" </span><span class="cov0" title="0">{
                        http.Redirect(w, r, "/", http.StatusSeeOther)
                        return
                }</span>
        }

        <span class="cov0" title="0">limit := r.URL.Query().Get("limit")
        fastSearch := r.URL.Query().Get("fast") == "true"
        isImageResults := r.URL.Query().Get("image_results") == "true"

        endpoint := "/api/search"
        if fastSearch </span><span class="cov0" title="0">{
                endpoint = "/api/isearch"
        }</span>

        <span class="cov0" title="0">apiURL := h.apiURL + endpoint + "?phrase=" + url.QueryEscape(query)
        if limit != "" </span><span class="cov0" title="0">{
                apiURL += "&amp;limit=" + url.QueryEscape(limit)
        }</span>

        <span class="cov0" title="0">resp, err := h.client.Get(apiURL)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Error("search API call failed",
                        "url", apiURL,
                        "error", err)
                http.Error(w, "Search service unavailable", http.StatusServiceUnavailable)
                return
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var result struct {
                Comics []struct {
                        ID    int     `json:"id"`
                        URL   string  `json:"url"`
                        Score float64 `json:"score"`
                } `json:"comics"`
                Total int `json:"total"`
        }

        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                h.log.Error("failed to decode search results", "error", err)
                http.Error(w, "Invalid response format", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">searchTime := time.Since(startTime)

        data := struct {
                Phrase         string
                Limit          string
                Fast           bool
                Total          int
                Comics         []Comic
                SearchTime     string
                IsImageResults bool
        }{
                Phrase:         query,
                Limit:          limit,
                Fast:           fastSearch,
                Total:          result.Total,
                Comics:         make([]Comic, len(result.Comics)),
                SearchTime:     fmt.Sprintf("%.2fms", float64(searchTime.Microseconds())/1000),
                IsImageResults: isImageResults,
        }

        for i, c := range result.Comics </span><span class="cov0" title="0">{
                data.Comics[i] = Comic{
                        ID:    c.ID,
                        URL:   c.URL,
                        Score: int(c.Score * 100),
                }
        }</span>

        <span class="cov0" title="0">if err := h.templates.ExecuteTemplate(w, "results.html", data); err != nil </span><span class="cov0" title="0">{
                h.log.Error("failed to render results", "error", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
        }</span>
}

// Admin - главная админ-панель
func (h *Handler) Admin(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        token, err := r.Cookie("admin_token")
        if err != nil || token.Value == "" </span><span class="cov0" title="0">{
                http.Redirect(w, r, "/admin/login", http.StatusSeeOther)
                return
        }</span>

        <span class="cov0" title="0">status, err := h.getStatus(token.Value)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Error("failed to get status", "error", err)
                http.Error(w, "Failed to get status", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">stats, err := h.getStats(token.Value)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Error("failed to get stats", "error", err)
                http.Error(w, "Failed to get stats", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">data := struct {
                Success string
                Status  UpdateStatus
                Stats   UpdateStats
        }{
                Success: r.URL.Query().Get("success"),
                Status:  status,
                Stats:   stats,
        }

        if err := h.templates.ExecuteTemplate(w, "admin.html", data); err != nil </span><span class="cov0" title="0">{
                h.log.Error("failed to render admin panel", "error", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
        }</span>
}

// Вспомогательные методы для получения данных
func (h *Handler) getStatus(token string) (UpdateStatus, error) <span class="cov0" title="0">{
        req, err := http.NewRequest("GET", h.apiURL+"/api/db/status", nil)
        if err != nil </span><span class="cov0" title="0">{
                return UpdateStatus{}, err
        }</span>
        //req.Header.Set("Authorization", "Token "+token)

        <span class="cov0" title="0">resp, err := h.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return UpdateStatus{}, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return UpdateStatus{}, fmt.Errorf("status request failed with code %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">var status UpdateStatus
        if err := json.NewDecoder(resp.Body).Decode(&amp;status); err != nil </span><span class="cov0" title="0">{
                return UpdateStatus{}, err
        }</span>

        <span class="cov0" title="0">return status, nil</span>
}

func (h *Handler) getStats(token string) (UpdateStats, error) <span class="cov0" title="0">{
        req, err := http.NewRequest("GET", h.apiURL+"/api/db/stats", nil)
        if err != nil </span><span class="cov0" title="0">{
                return UpdateStats{}, err
        }</span>
        //req.Header.Set("Authorization", "Token "+token)

        <span class="cov0" title="0">resp, err := h.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return UpdateStats{}, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return UpdateStats{}, fmt.Errorf("stats request failed with code %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">var stats UpdateStats
        if err := json.NewDecoder(resp.Body).Decode(&amp;stats); err != nil </span><span class="cov0" title="0">{
                return UpdateStats{}, err
        }</span>

        <span class="cov0" title="0">return stats, nil</span>
}

func (h *Handler) AdminLogin(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        err := h.templates.ExecuteTemplate(w, "login.html", map[string]interface{}{
                "Error": r.URL.Query().Get("error") == "1",
        })
        if err != nil </span><span class="cov0" title="0">{
                h.log.Error("failed to render template", "error", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
        }</span>
}

// AdminLoginPost - обработчик формы входа
func (h *Handler) AdminLoginPost(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        username := r.FormValue("username")
        password := r.FormValue("password")

        type LoginRequest struct {
                Name     string `json:"name"`
                Password string `json:"password"`
        }

        loginData := LoginRequest{
                Name:     username,
                Password: password,
        }

        jsonData, err := json.Marshal(loginData)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Error("Failed to encode login data", "error", err)
                http.Redirect(w, r, "/admin/login?error=1", http.StatusSeeOther)
                return
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("POST", h.apiURL+"/api/login", bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                h.log.Error("Failed to create request", "error", err)
                http.Redirect(w, r, "/admin/login?error=1", http.StatusSeeOther)
                return
        }</span>
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")

        resp, err := h.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Error("Login API call failed", "error", err)
                http.Redirect(w, r, "/admin/login?error=1", http.StatusSeeOther)
                return
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                h.log.Warn("Login failed", "status", resp.StatusCode)
                http.Redirect(w, r, "/admin/login?error=1", http.StatusSeeOther)
                return
        }</span>

        <span class="cov0" title="0">token, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Error("Failed to read token", "error", err)
                http.Redirect(w, r, "/admin/login?error=1", http.StatusSeeOther)
                return
        }</span>

        <span class="cov0" title="0">http.SetCookie(w, &amp;http.Cookie{
                Name:     "admin_token",
                Value:    string(token),
                Path:     "/admin",
                HttpOnly: true,
                Secure:   true,
                MaxAge:   120,
                SameSite: http.SameSiteLaxMode,
        })

        http.Redirect(w, r, "/admin", http.StatusSeeOther)</span>
}

func (h *Handler) AdminUpdate(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        token, err := r.Cookie("admin_token")
        if err != nil </span><span class="cov0" title="0">{
                http.Redirect(w, r, "/admin/login", http.StatusSeeOther)
                return
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("POST", h.apiURL+"/api/db/update", nil)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Error("failed to create update request", "error", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">req.Header.Add("Authorization", "Token "+token.Value)

        resp, err := h.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Error("update API call failed", "error", err)
                http.Error(w, "Update service unavailable", http.StatusServiceUnavailable)
                return
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                h.log.Error("update failed", "status", resp.Status, "body", string(body))
                http.Error(w, "Update failed", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">http.Redirect(w, r, "/admin?success=update", http.StatusSeeOther)</span>
}

func (h *Handler) AdminDrop(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        token, err := r.Cookie("admin_token")
        if err != nil </span><span class="cov0" title="0">{
                http.Redirect(w, r, "/admin/login", http.StatusSeeOther)
                return
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("DELETE", h.apiURL+"/api/db", nil)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Error("failed to create update request", "error", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">req.Header.Add("Authorization", "Token "+token.Value)

        resp, err := h.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Error("drop API call failed", "error", err)
                http.Error(w, "drop service unavailable", http.StatusServiceUnavailable)
                return
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                h.log.Error("drop failed", "status", resp.Status, "body", string(body))
                http.Error(w, "drop failed", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">http.Redirect(w, r, "/admin?success=drop", http.StatusSeeOther)</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package main

import (
        "context"
        "log/slog"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"
        "yadro.com/course/comic-frontend/config"
        "yadro.com/course/comic-frontend/handlers"
)

func main() <span class="cov0" title="0">{
        cfg := config.MustLoad("config.yaml")

        log := setupLogger(cfg.LogLevel)

        client := &amp;http.Client{
                Timeout: cfg.Server.Timeout,
        }

        // Инициализация обработчиков с использованием статей:
        // - https://gowebexamples.com/templates/ (для шаблонов)
        // - https://www.alexedwards.net/blog/working-with-cookies-in-go (для cookies)
        handler := handlers.NewHandler(log, client, cfg.API.ApiURL)

        mux := http.NewServeMux()

        mux.HandleFunc("GET /{$}", handler.Index)
        mux.HandleFunc("GET /search", handler.Search)
        mux.HandleFunc("GET /image-search", handler.ImageSearch)
        mux.HandleFunc("POST  /detect", handler.Detect)

        // Админские маршруты
        mux.HandleFunc("GET /admin", handler.Admin)
        mux.HandleFunc("GET /admin/login", handler.AdminLogin)
        mux.HandleFunc("POST /admin/login", handler.AdminLoginPost)
        mux.HandleFunc("POST /admin/update", handler.AdminUpdate)
        mux.HandleFunc("POST /admin/drop", handler.AdminDrop)

        srv := &amp;http.Server{
                Addr:    cfg.Server.Address,
                Handler: mux,
        }

        ctx, stop := signal.NotifyContext(context.Background(),
                syscall.SIGINT, syscall.SIGTERM)
        defer stop()

        go func() </span><span class="cov0" title="0">{
                log.Info("Starting server", "address", cfg.Server.Address)
                if err := srv.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Error("Server failed", "error", err)
                }</span>
        }()

        <span class="cov0" title="0">&lt;-ctx.Done()
        log.Info("Shutting down server...")

        shutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if err := srv.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                log.Error("Server shutdown error", "error", err)
        }</span>
        <span class="cov0" title="0">log.Info("Server stopped")</span>
}

func setupLogger(level string) *slog.Logger <span class="cov0" title="0">{
        var logLevel slog.Level
        switch level </span>{
        case "DEBUG":<span class="cov0" title="0">
                logLevel = slog.LevelDebug</span>
        case "INFO":<span class="cov0" title="0">
                logLevel = slog.LevelInfo</span>
        case "WARN":<span class="cov0" title="0">
                logLevel = slog.LevelWarn</span>
        case "ERROR":<span class="cov0" title="0">
                logLevel = slog.LevelError</span>
        default:<span class="cov0" title="0">
                logLevel = slog.LevelInfo</span>
        }
        <span class="cov0" title="0">return slog.New(slog.NewTextHandler(os.Stdout, &amp;slog.HandlerOptions{
                Level: logLevel,
        }))</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.5
//         protoc        v6.30.0--rc1
// source: search/search.proto

package search

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type IndexSearchRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Phrase        string                 `protobuf:"bytes,1,opt,name=phrase,proto3" json:"phrase,omitempty"`
        Limit         int32                  `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *IndexSearchRequest) Reset() <span class="cov0" title="0">{
        *x = IndexSearchRequest{}
        mi := &amp;file_search_search_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *IndexSearchRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*IndexSearchRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *IndexSearchRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_search_search_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use IndexSearchRequest.ProtoReflect.Descriptor instead.
func (*IndexSearchRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_search_search_proto_rawDescGZIP(), []int{0}
}</span>

func (x *IndexSearchRequest) GetPhrase() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Phrase
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *IndexSearchRequest) GetLimit() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Limit
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type SearchRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Phrase        string                 `protobuf:"bytes,1,opt,name=phrase,proto3" json:"phrase,omitempty"`
        Limit         int32                  `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *SearchRequest) Reset() <span class="cov0" title="0">{
        *x = SearchRequest{}
        mi := &amp;file_search_search_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SearchRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SearchRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SearchRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_search_search_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SearchRequest.ProtoReflect.Descriptor instead.
func (*SearchRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_search_search_proto_rawDescGZIP(), []int{1}
}</span>

func (x *SearchRequest) GetPhrase() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Phrase
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SearchRequest) GetLimit() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Limit
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type SearchResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Comics        []*Comic               `protobuf:"bytes,1,rep,name=comics,proto3" json:"comics,omitempty"`
        Total         int32                  `protobuf:"varint,2,opt,name=total,proto3" json:"total,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *SearchResponse) Reset() <span class="cov0" title="0">{
        *x = SearchResponse{}
        mi := &amp;file_search_search_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SearchResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SearchResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SearchResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_search_search_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SearchResponse.ProtoReflect.Descriptor instead.
func (*SearchResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_search_search_proto_rawDescGZIP(), []int{2}
}</span>

func (x *SearchResponse) GetComics() []*Comic <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Comics
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SearchResponse) GetTotal() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Total
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type Comic struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            int32                  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        Url           string                 `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Comic) Reset() <span class="cov0" title="0">{
        *x = Comic{}
        mi := &amp;file_search_search_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Comic) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Comic) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Comic) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_search_search_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Comic.ProtoReflect.Descriptor instead.
func (*Comic) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_search_search_proto_rawDescGZIP(), []int{3}
}</span>

func (x *Comic) GetId() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Comic) GetUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Url
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_search_search_proto protoreflect.FileDescriptor

var file_search_search_proto_rawDesc = string([]byte{
        0x0a, 0x13, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2f, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x06, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x1a, 0x1b, 0x67,
        0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x65,
        0x6d, 0x70, 0x74, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x42, 0x0a, 0x12, 0x49, 0x6e,
        0x64, 0x65, 0x78, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x12, 0x16, 0x0a, 0x06, 0x70, 0x68, 0x72, 0x61, 0x73, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x06, 0x70, 0x68, 0x72, 0x61, 0x73, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x6c, 0x69, 0x6d, 0x69,
        0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x22, 0x3d,
        0x0a, 0x0d, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12,
        0x16, 0x0a, 0x06, 0x70, 0x68, 0x72, 0x61, 0x73, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x06, 0x70, 0x68, 0x72, 0x61, 0x73, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x6c, 0x69, 0x6d, 0x69, 0x74,
        0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x22, 0x4d, 0x0a,
        0x0e, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,
        0x25, 0x0a, 0x06, 0x63, 0x6f, 0x6d, 0x69, 0x63, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32,
        0x0d, 0x2e, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x43, 0x6f, 0x6d, 0x69, 0x63, 0x52, 0x06,
        0x63, 0x6f, 0x6d, 0x69, 0x63, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x22, 0x29, 0x0a, 0x05,
        0x43, 0x6f, 0x6d, 0x69, 0x63, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x05, 0x52, 0x02, 0x69, 0x64, 0x12, 0x10, 0x0a, 0x03, 0x75, 0x72, 0x6c, 0x18, 0x02, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x03, 0x75, 0x72, 0x6c, 0x32, 0xbc, 0x01, 0x0a, 0x06, 0x53, 0x65, 0x61, 0x72,
        0x63, 0x68, 0x12, 0x37, 0x0a, 0x06, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68, 0x12, 0x15, 0x2e, 0x73,
        0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68, 0x52, 0x65, 0x71, 0x75,
        0x65, 0x73, 0x74, 0x1a, 0x16, 0x2e, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x53, 0x65, 0x61,
        0x72, 0x63, 0x68, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x41, 0x0a, 0x0b, 0x49,
        0x6e, 0x64, 0x65, 0x78, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68, 0x12, 0x1a, 0x2e, 0x73, 0x65, 0x61,
        0x72, 0x63, 0x68, 0x2e, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68, 0x52,
        0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x16, 0x2e, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e,
        0x53, 0x65, 0x61, 0x72, 0x63, 0x68, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x36,
        0x0a, 0x04, 0x50, 0x69, 0x6e, 0x67, 0x12, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x1a, 0x16,
        0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66,
        0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x42, 0x1e, 0x5a, 0x1c, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68,
        0x2d, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f,
        0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
})

var (
        file_search_search_proto_rawDescOnce sync.Once
        file_search_search_proto_rawDescData []byte
)

func file_search_search_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_search_search_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_search_search_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_search_search_proto_rawDesc), len(file_search_search_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_search_search_proto_rawDescData</span>
}

var file_search_search_proto_msgTypes = make([]protoimpl.MessageInfo, 4)
var file_search_search_proto_goTypes = []any{
        (*IndexSearchRequest)(nil), // 0: search.IndexSearchRequest
        (*SearchRequest)(nil),      // 1: search.SearchRequest
        (*SearchResponse)(nil),     // 2: search.SearchResponse
        (*Comic)(nil),              // 3: search.Comic
        (*emptypb.Empty)(nil),      // 4: google.protobuf.Empty
}
var file_search_search_proto_depIdxs = []int32{
        3, // 0: search.SearchResponse.comics:type_name -&gt; search.Comic
        1, // 1: search.Search.Search:input_type -&gt; search.SearchRequest
        0, // 2: search.Search.IndexSearch:input_type -&gt; search.IndexSearchRequest
        4, // 3: search.Search.Ping:input_type -&gt; google.protobuf.Empty
        2, // 4: search.Search.Search:output_type -&gt; search.SearchResponse
        2, // 5: search.Search.IndexSearch:output_type -&gt; search.SearchResponse
        4, // 6: search.Search.Ping:output_type -&gt; google.protobuf.Empty
        4, // [4:7] is the sub-list for method output_type
        1, // [1:4] is the sub-list for method input_type
        1, // [1:1] is the sub-list for extension type_name
        1, // [1:1] is the sub-list for extension extendee
        0, // [0:1] is the sub-list for field type_name
}

func init() <span class="cov10" title="2">{ file_search_search_proto_init() }</span>
func file_search_search_proto_init() <span class="cov10" title="2">{
        if File_search_search_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov10" title="2">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_search_search_proto_rawDesc), len(file_search_search_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   4,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_search_search_proto_goTypes,
                DependencyIndexes: file_search_search_proto_depIdxs,
                MessageInfos:      file_search_search_proto_msgTypes,
        }.Build()
        File_search_search_proto = out.File
        file_search_search_proto_goTypes = nil
        file_search_search_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.30.0--rc1
// source: search/search.proto

package search

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        Search_Search_FullMethodName      = "/search.Search/Search"
        Search_IndexSearch_FullMethodName = "/search.Search/IndexSearch"
        Search_Ping_FullMethodName        = "/search.Search/Ping"
)

// SearchClient is the client API for Search service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SearchClient interface {
        Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error)
        IndexSearch(ctx context.Context, in *IndexSearchRequest, opts ...grpc.CallOption) (*SearchResponse, error)
        Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type searchClient struct {
        cc grpc.ClientConnInterface
}

func NewSearchClient(cc grpc.ClientConnInterface) SearchClient <span class="cov0" title="0">{
        return &amp;searchClient{cc}
}</span>

func (c *searchClient) Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(SearchResponse)
        err := c.cc.Invoke(ctx, Search_Search_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *searchClient) IndexSearch(ctx context.Context, in *IndexSearchRequest, opts ...grpc.CallOption) (*SearchResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(SearchResponse)
        err := c.cc.Invoke(ctx, Search_IndexSearch_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *searchClient) Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(emptypb.Empty)
        err := c.cc.Invoke(ctx, Search_Ping_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// SearchServer is the server API for Search service.
// All implementations must embed UnimplementedSearchServer
// for forward compatibility.
type SearchServer interface {
        Search(context.Context, *SearchRequest) (*SearchResponse, error)
        IndexSearch(context.Context, *IndexSearchRequest) (*SearchResponse, error)
        Ping(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
        mustEmbedUnimplementedSearchServer()
}

// UnimplementedSearchServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSearchServer struct{}

func (UnimplementedSearchServer) Search(context.Context, *SearchRequest) (*SearchResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Search not implemented")
}</span>
func (UnimplementedSearchServer) IndexSearch(context.Context, *IndexSearchRequest) (*SearchResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method IndexSearch not implemented")
}</span>
func (UnimplementedSearchServer) Ping(context.Context, *emptypb.Empty) (*emptypb.Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}</span>
func (UnimplementedSearchServer) mustEmbedUnimplementedSearchServer() {<span class="cov0" title="0">}</span>
func (UnimplementedSearchServer) testEmbeddedByValue()                {<span class="cov0" title="0">}</span>

// UnsafeSearchServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SearchServer will
// result in compilation errors.
type UnsafeSearchServer interface {
        mustEmbedUnimplementedSearchServer()
}

func RegisterSearchServer(s grpc.ServiceRegistrar, srv SearchServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedSearchServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;Search_ServiceDesc, srv)</span>
}

func _Search_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(SearchRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(SearchServer).Search(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Search_Search_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(SearchServer).Search(ctx, req.(*SearchRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Search_IndexSearch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(IndexSearchRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(SearchServer).IndexSearch(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Search_IndexSearch_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(SearchServer).IndexSearch(ctx, req.(*IndexSearchRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Search_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(emptypb.Empty)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(SearchServer).Ping(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Search_Ping_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(SearchServer).Ping(ctx, req.(*emptypb.Empty))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// Search_ServiceDesc is the grpc.ServiceDesc for Search service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Search_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "search.Search",
        HandlerType: (*SearchServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Search",
                        Handler:    _Search_Search_Handler,
                },
                {
                        MethodName: "IndexSearch",
                        Handler:    _Search_IndexSearch_Handler,
                },
                {
                        MethodName: "Ping",
                        Handler:    _Search_Ping_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "search/search.proto",
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.5
//         protoc        v6.30.0--rc1
// source: proto/update/update.proto

package update

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Status int32

const (
        Status_STATUS_UNSPECIFIED Status = 0
        Status_STATUS_IDLE        Status = 1
        Status_STATUS_RUNNING     Status = 2
)

// Enum value maps for Status.
var (
        Status_name = map[int32]string{
                0: "STATUS_UNSPECIFIED",
                1: "STATUS_IDLE",
                2: "STATUS_RUNNING",
        }
        Status_value = map[string]int32{
                "STATUS_UNSPECIFIED": 0,
                "STATUS_IDLE":        1,
                "STATUS_RUNNING":     2,
        }
)

func (x Status) Enum() *Status <span class="cov0" title="0">{
        p := new(Status)
        *p = x
        return p
}</span>

func (x Status) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (Status) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_proto_update_update_proto_enumTypes[0].Descriptor()
}</span>

func (Status) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_proto_update_update_proto_enumTypes[0]
}</span>

func (x Status) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use Status.Descriptor instead.
func (Status) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_update_update_proto_rawDescGZIP(), []int{0}
}</span>

type StatsReply struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        WordsTotal    int64                  `protobuf:"varint,1,opt,name=words_total,json=wordsTotal,proto3" json:"words_total,omitempty"`
        WordsUnique   int64                  `protobuf:"varint,2,opt,name=words_unique,json=wordsUnique,proto3" json:"words_unique,omitempty"`
        ComicsTotal   int64                  `protobuf:"varint,3,opt,name=comics_total,json=comicsTotal,proto3" json:"comics_total,omitempty"`
        ComicsFetched int64                  `protobuf:"varint,4,opt,name=comics_fetched,json=comicsFetched,proto3" json:"comics_fetched,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *StatsReply) Reset() <span class="cov0" title="0">{
        *x = StatsReply{}
        mi := &amp;file_proto_update_update_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *StatsReply) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StatsReply) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StatsReply) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_update_update_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StatsReply.ProtoReflect.Descriptor instead.
func (*StatsReply) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_update_update_proto_rawDescGZIP(), []int{0}
}</span>

func (x *StatsReply) GetWordsTotal() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.WordsTotal
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *StatsReply) GetWordsUnique() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.WordsUnique
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *StatsReply) GetComicsTotal() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ComicsTotal
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *StatsReply) GetComicsFetched() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ComicsFetched
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type StatusReply struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Status        Status                 `protobuf:"varint,1,opt,name=status,proto3,enum=update.Status" json:"status,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *StatusReply) Reset() <span class="cov0" title="0">{
        *x = StatusReply{}
        mi := &amp;file_proto_update_update_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *StatusReply) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StatusReply) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StatusReply) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_update_update_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StatusReply.ProtoReflect.Descriptor instead.
func (*StatusReply) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_update_update_proto_rawDescGZIP(), []int{1}
}</span>

func (x *StatusReply) GetStatus() Status <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return Status_STATUS_UNSPECIFIED</span>
}

var File_proto_update_update_proto protoreflect.FileDescriptor

var file_proto_update_update_proto_rawDesc = string([]byte{
        0x0a, 0x19, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x2f, 0x75,
        0x70, 0x64, 0x61, 0x74, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x06, 0x75, 0x70, 0x64,
        0x61, 0x74, 0x65, 0x1a, 0x1b, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x62, 0x75, 0x66, 0x2f, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x22, 0x9a, 0x01, 0x0a, 0x0a, 0x53, 0x74, 0x61, 0x74, 0x73, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x12,
        0x1f, 0x0a, 0x0b, 0x77, 0x6f, 0x72, 0x64, 0x73, 0x5f, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x03, 0x52, 0x0a, 0x77, 0x6f, 0x72, 0x64, 0x73, 0x54, 0x6f, 0x74, 0x61, 0x6c,
        0x12, 0x21, 0x0a, 0x0c, 0x77, 0x6f, 0x72, 0x64, 0x73, 0x5f, 0x75, 0x6e, 0x69, 0x71, 0x75, 0x65,
        0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0b, 0x77, 0x6f, 0x72, 0x64, 0x73, 0x55, 0x6e, 0x69,
        0x71, 0x75, 0x65, 0x12, 0x21, 0x0a, 0x0c, 0x63, 0x6f, 0x6d, 0x69, 0x63, 0x73, 0x5f, 0x74, 0x6f,
        0x74, 0x61, 0x6c, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0b, 0x63, 0x6f, 0x6d, 0x69, 0x63,
        0x73, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x12, 0x25, 0x0a, 0x0e, 0x63, 0x6f, 0x6d, 0x69, 0x63, 0x73,
        0x5f, 0x66, 0x65, 0x74, 0x63, 0x68, 0x65, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0d,
        0x63, 0x6f, 0x6d, 0x69, 0x63, 0x73, 0x46, 0x65, 0x74, 0x63, 0x68, 0x65, 0x64, 0x22, 0x35, 0x0a,
        0x0b, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x12, 0x26, 0x0a, 0x06,
        0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x0e, 0x2e, 0x75,
        0x70, 0x64, 0x61, 0x74, 0x65, 0x2e, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x06, 0x73, 0x74,
        0x61, 0x74, 0x75, 0x73, 0x2a, 0x45, 0x0a, 0x06, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x16,
        0x0a, 0x12, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49,
        0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x0f, 0x0a, 0x0b, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53,
        0x5f, 0x49, 0x44, 0x4c, 0x45, 0x10, 0x01, 0x12, 0x12, 0x0a, 0x0e, 0x53, 0x54, 0x41, 0x54, 0x55,
        0x53, 0x5f, 0x52, 0x55, 0x4e, 0x4e, 0x49, 0x4e, 0x47, 0x10, 0x02, 0x32, 0xa8, 0x02, 0x0a, 0x06,
        0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x12, 0x38, 0x0a, 0x04, 0x50, 0x69, 0x6e, 0x67, 0x12, 0x16,
        0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66,
        0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x1a, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0x00,
        0x12, 0x37, 0x0a, 0x06, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x16, 0x2e, 0x67, 0x6f, 0x6f,
        0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70,
        0x74, 0x79, 0x1a, 0x13, 0x2e, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x2e, 0x53, 0x74, 0x61, 0x74,
        0x75, 0x73, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x22, 0x00, 0x12, 0x3a, 0x0a, 0x06, 0x55, 0x70, 0x64,
        0x61, 0x74, 0x65, 0x12, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x1a, 0x16, 0x2e, 0x67, 0x6f,
        0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d,
        0x70, 0x74, 0x79, 0x22, 0x00, 0x12, 0x35, 0x0a, 0x05, 0x53, 0x74, 0x61, 0x74, 0x73, 0x12, 0x16,
        0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66,
        0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x1a, 0x12, 0x2e, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x2e,
        0x53, 0x74, 0x61, 0x74, 0x73, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x22, 0x00, 0x12, 0x38, 0x0a, 0x04,
        0x44, 0x72, 0x6f, 0x70, 0x12, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x1a, 0x16, 0x2e, 0x67,
        0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x45,
        0x6d, 0x70, 0x74, 0x79, 0x22, 0x00, 0x42, 0x1f, 0x5a, 0x1d, 0x79, 0x61, 0x64, 0x72, 0x6f, 0x2e,
        0x63, 0x6f, 0x6d, 0x2f, 0x63, 0x6f, 0x75, 0x72, 0x73, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x2f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
})

var (
        file_proto_update_update_proto_rawDescOnce sync.Once
        file_proto_update_update_proto_rawDescData []byte
)

func file_proto_update_update_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_proto_update_update_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_proto_update_update_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_proto_update_update_proto_rawDesc), len(file_proto_update_update_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_proto_update_update_proto_rawDescData</span>
}

var file_proto_update_update_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_proto_update_update_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_proto_update_update_proto_goTypes = []any{
        (Status)(0),           // 0: update.Status
        (*StatsReply)(nil),    // 1: update.StatsReply
        (*StatusReply)(nil),   // 2: update.StatusReply
        (*emptypb.Empty)(nil), // 3: google.protobuf.Empty
}
var file_proto_update_update_proto_depIdxs = []int32{
        0, // 0: update.StatusReply.status:type_name -&gt; update.Status
        3, // 1: update.Update.Ping:input_type -&gt; google.protobuf.Empty
        3, // 2: update.Update.Status:input_type -&gt; google.protobuf.Empty
        3, // 3: update.Update.Update:input_type -&gt; google.protobuf.Empty
        3, // 4: update.Update.Stats:input_type -&gt; google.protobuf.Empty
        3, // 5: update.Update.Drop:input_type -&gt; google.protobuf.Empty
        3, // 6: update.Update.Ping:output_type -&gt; google.protobuf.Empty
        2, // 7: update.Update.Status:output_type -&gt; update.StatusReply
        3, // 8: update.Update.Update:output_type -&gt; google.protobuf.Empty
        1, // 9: update.Update.Stats:output_type -&gt; update.StatsReply
        3, // 10: update.Update.Drop:output_type -&gt; google.protobuf.Empty
        6, // [6:11] is the sub-list for method output_type
        1, // [1:6] is the sub-list for method input_type
        1, // [1:1] is the sub-list for extension type_name
        1, // [1:1] is the sub-list for extension extendee
        0, // [0:1] is the sub-list for field type_name
}

func init() <span class="cov10" title="2">{ file_proto_update_update_proto_init() }</span>
func file_proto_update_update_proto_init() <span class="cov10" title="2">{
        if File_proto_update_update_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov10" title="2">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_proto_update_update_proto_rawDesc), len(file_proto_update_update_proto_rawDesc)),
                        NumEnums:      1,
                        NumMessages:   2,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_proto_update_update_proto_goTypes,
                DependencyIndexes: file_proto_update_update_proto_depIdxs,
                EnumInfos:         file_proto_update_update_proto_enumTypes,
                MessageInfos:      file_proto_update_update_proto_msgTypes,
        }.Build()
        File_proto_update_update_proto = out.File
        file_proto_update_update_proto_goTypes = nil
        file_proto_update_update_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.30.0--rc1
// source: proto/update/update.proto

package update

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        Update_Ping_FullMethodName   = "/update.Update/Ping"
        Update_Status_FullMethodName = "/update.Update/Status"
        Update_Update_FullMethodName = "/update.Update/Update"
        Update_Stats_FullMethodName  = "/update.Update/Stats"
        Update_Drop_FullMethodName   = "/update.Update/Drop"
)

// UpdateClient is the client API for Update service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UpdateClient interface {
        Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
        Status(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*StatusReply, error)
        Update(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
        Stats(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*StatsReply, error)
        Drop(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type updateClient struct {
        cc grpc.ClientConnInterface
}

func NewUpdateClient(cc grpc.ClientConnInterface) UpdateClient <span class="cov0" title="0">{
        return &amp;updateClient{cc}
}</span>

func (c *updateClient) Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(emptypb.Empty)
        err := c.cc.Invoke(ctx, Update_Ping_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *updateClient) Status(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*StatusReply, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(StatusReply)
        err := c.cc.Invoke(ctx, Update_Status_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *updateClient) Update(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(emptypb.Empty)
        err := c.cc.Invoke(ctx, Update_Update_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *updateClient) Stats(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*StatsReply, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(StatsReply)
        err := c.cc.Invoke(ctx, Update_Stats_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *updateClient) Drop(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(emptypb.Empty)
        err := c.cc.Invoke(ctx, Update_Drop_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// UpdateServer is the server API for Update service.
// All implementations must embed UnimplementedUpdateServer
// for forward compatibility.
type UpdateServer interface {
        Ping(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
        Status(context.Context, *emptypb.Empty) (*StatusReply, error)
        Update(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
        Stats(context.Context, *emptypb.Empty) (*StatsReply, error)
        Drop(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
        mustEmbedUnimplementedUpdateServer()
}

// UnimplementedUpdateServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUpdateServer struct{}

func (UnimplementedUpdateServer) Ping(context.Context, *emptypb.Empty) (*emptypb.Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}</span>
func (UnimplementedUpdateServer) Status(context.Context, *emptypb.Empty) (*StatusReply, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Status not implemented")
}</span>
func (UnimplementedUpdateServer) Update(context.Context, *emptypb.Empty) (*emptypb.Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}</span>
func (UnimplementedUpdateServer) Stats(context.Context, *emptypb.Empty) (*StatsReply, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Stats not implemented")
}</span>
func (UnimplementedUpdateServer) Drop(context.Context, *emptypb.Empty) (*emptypb.Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Drop not implemented")
}</span>
func (UnimplementedUpdateServer) mustEmbedUnimplementedUpdateServer() {<span class="cov0" title="0">}</span>
func (UnimplementedUpdateServer) testEmbeddedByValue()                {<span class="cov0" title="0">}</span>

// UnsafeUpdateServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UpdateServer will
// result in compilation errors.
type UnsafeUpdateServer interface {
        mustEmbedUnimplementedUpdateServer()
}

func RegisterUpdateServer(s grpc.ServiceRegistrar, srv UpdateServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedUpdateServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;Update_ServiceDesc, srv)</span>
}

func _Update_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(emptypb.Empty)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UpdateServer).Ping(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Update_Ping_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UpdateServer).Ping(ctx, req.(*emptypb.Empty))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Update_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(emptypb.Empty)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UpdateServer).Status(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Update_Status_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UpdateServer).Status(ctx, req.(*emptypb.Empty))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Update_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(emptypb.Empty)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UpdateServer).Update(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Update_Update_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UpdateServer).Update(ctx, req.(*emptypb.Empty))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Update_Stats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(emptypb.Empty)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UpdateServer).Stats(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Update_Stats_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UpdateServer).Stats(ctx, req.(*emptypb.Empty))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Update_Drop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(emptypb.Empty)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UpdateServer).Drop(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Update_Drop_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UpdateServer).Drop(ctx, req.(*emptypb.Empty))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// Update_ServiceDesc is the grpc.ServiceDesc for Update service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Update_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "update.Update",
        HandlerType: (*UpdateServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Ping",
                        Handler:    _Update_Ping_Handler,
                },
                {
                        MethodName: "Status",
                        Handler:    _Update_Status_Handler,
                },
                {
                        MethodName: "Update",
                        Handler:    _Update_Update_Handler,
                },
                {
                        MethodName: "Stats",
                        Handler:    _Update_Stats_Handler,
                },
                {
                        MethodName: "Drop",
                        Handler:    _Update_Drop_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "proto/update/update.proto",
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.5
//         protoc        v6.30.0--rc1
// source: proto/words/words.proto

package words

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type WordsRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Phrase        string                 `protobuf:"bytes,1,opt,name=phrase,proto3" json:"phrase,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *WordsRequest) Reset() <span class="cov0" title="0">{
        *x = WordsRequest{}
        mi := &amp;file_proto_words_words_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *WordsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*WordsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *WordsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_words_words_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use WordsRequest.ProtoReflect.Descriptor instead.
func (*WordsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_words_words_proto_rawDescGZIP(), []int{0}
}</span>

func (x *WordsRequest) GetPhrase() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Phrase
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type WordsReply struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Words         []string               `protobuf:"bytes,1,rep,name=words,proto3" json:"words,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *WordsReply) Reset() <span class="cov0" title="0">{
        *x = WordsReply{}
        mi := &amp;file_proto_words_words_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *WordsReply) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*WordsReply) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *WordsReply) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_words_words_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use WordsReply.ProtoReflect.Descriptor instead.
func (*WordsReply) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_words_words_proto_rawDescGZIP(), []int{1}
}</span>

func (x *WordsReply) GetWords() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Words
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_proto_words_words_proto protoreflect.FileDescriptor

var file_proto_words_words_proto_rawDesc = string([]byte{
        0x0a, 0x17, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x77, 0x6f, 0x72, 0x64, 0x73, 0x2f, 0x77, 0x6f,
        0x72, 0x64, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x05, 0x77, 0x6f, 0x72, 0x64, 0x73,
        0x1a, 0x1b, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75,
        0x66, 0x2f, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x26, 0x0a,
        0x0c, 0x57, 0x6f, 0x72, 0x64, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x16, 0x0a,
        0x06, 0x70, 0x68, 0x72, 0x61, 0x73, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x70,
        0x68, 0x72, 0x61, 0x73, 0x65, 0x22, 0x22, 0x0a, 0x0a, 0x57, 0x6f, 0x72, 0x64, 0x73, 0x52, 0x65,
        0x70, 0x6c, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x77, 0x6f, 0x72, 0x64, 0x73, 0x18, 0x01, 0x20, 0x03,
        0x28, 0x09, 0x52, 0x05, 0x77, 0x6f, 0x72, 0x64, 0x73, 0x32, 0x73, 0x0a, 0x05, 0x57, 0x6f, 0x72,
        0x64, 0x73, 0x12, 0x38, 0x0a, 0x04, 0x50, 0x69, 0x6e, 0x67, 0x12, 0x16, 0x2e, 0x67, 0x6f, 0x6f,
        0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70,
        0x74, 0x79, 0x1a, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0x00, 0x12, 0x30, 0x0a, 0x04,
        0x4e, 0x6f, 0x72, 0x6d, 0x12, 0x13, 0x2e, 0x77, 0x6f, 0x72, 0x64, 0x73, 0x2e, 0x57, 0x6f, 0x72,
        0x64, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x11, 0x2e, 0x77, 0x6f, 0x72, 0x64,
        0x73, 0x2e, 0x57, 0x6f, 0x72, 0x64, 0x73, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x22, 0x00, 0x42, 0x1e,
        0x5a, 0x1c, 0x79, 0x61, 0x64, 0x72, 0x6f, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x63, 0x6f, 0x75, 0x72,
        0x73, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x77, 0x6f, 0x72, 0x64, 0x73, 0x62, 0x06,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
})

var (
        file_proto_words_words_proto_rawDescOnce sync.Once
        file_proto_words_words_proto_rawDescData []byte
)

func file_proto_words_words_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_proto_words_words_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_proto_words_words_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_proto_words_words_proto_rawDesc), len(file_proto_words_words_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_proto_words_words_proto_rawDescData</span>
}

var file_proto_words_words_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_proto_words_words_proto_goTypes = []any{
        (*WordsRequest)(nil),  // 0: words.WordsRequest
        (*WordsReply)(nil),    // 1: words.WordsReply
        (*emptypb.Empty)(nil), // 2: google.protobuf.Empty
}
var file_proto_words_words_proto_depIdxs = []int32{
        2, // 0: words.Words.Ping:input_type -&gt; google.protobuf.Empty
        0, // 1: words.Words.Norm:input_type -&gt; words.WordsRequest
        2, // 2: words.Words.Ping:output_type -&gt; google.protobuf.Empty
        1, // 3: words.Words.Norm:output_type -&gt; words.WordsReply
        2, // [2:4] is the sub-list for method output_type
        0, // [0:2] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov10" title="3">{ file_proto_words_words_proto_init() }</span>
func file_proto_words_words_proto_init() <span class="cov10" title="3">{
        if File_proto_words_words_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov10" title="3">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_proto_words_words_proto_rawDesc), len(file_proto_words_words_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   2,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_proto_words_words_proto_goTypes,
                DependencyIndexes: file_proto_words_words_proto_depIdxs,
                MessageInfos:      file_proto_words_words_proto_msgTypes,
        }.Build()
        File_proto_words_words_proto = out.File
        file_proto_words_words_proto_goTypes = nil
        file_proto_words_words_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.30.0--rc1
// source: proto/words/words.proto

package words

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        Words_Ping_FullMethodName = "/words.Words/Ping"
        Words_Norm_FullMethodName = "/words.Words/Norm"
)

// WordsClient is the client API for Words service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Service
type WordsClient interface {
        Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
        // Send name, receive greeting
        Norm(ctx context.Context, in *WordsRequest, opts ...grpc.CallOption) (*WordsReply, error)
}

type wordsClient struct {
        cc grpc.ClientConnInterface
}

func NewWordsClient(cc grpc.ClientConnInterface) WordsClient <span class="cov10" title="2">{
        return &amp;wordsClient{cc}
}</span>

func (c *wordsClient) Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(emptypb.Empty)
        err := c.cc.Invoke(ctx, Words_Ping_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *wordsClient) Norm(ctx context.Context, in *WordsRequest, opts ...grpc.CallOption) (*WordsReply, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(WordsReply)
        err := c.cc.Invoke(ctx, Words_Norm_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// WordsServer is the server API for Words service.
// All implementations must embed UnimplementedWordsServer
// for forward compatibility.
//
// Service
type WordsServer interface {
        Ping(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
        // Send name, receive greeting
        Norm(context.Context, *WordsRequest) (*WordsReply, error)
        mustEmbedUnimplementedWordsServer()
}

// UnimplementedWordsServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedWordsServer struct{}

func (UnimplementedWordsServer) Ping(context.Context, *emptypb.Empty) (*emptypb.Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}</span>
func (UnimplementedWordsServer) Norm(context.Context, *WordsRequest) (*WordsReply, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Norm not implemented")
}</span>
func (UnimplementedWordsServer) mustEmbedUnimplementedWordsServer() {<span class="cov0" title="0">}</span>
func (UnimplementedWordsServer) testEmbeddedByValue()               {<span class="cov0" title="0">}</span>

// UnsafeWordsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WordsServer will
// result in compilation errors.
type UnsafeWordsServer interface {
        mustEmbedUnimplementedWordsServer()
}

func RegisterWordsServer(s grpc.ServiceRegistrar, srv WordsServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedWordsServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;Words_ServiceDesc, srv)</span>
}

func _Words_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(emptypb.Empty)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(WordsServer).Ping(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Words_Ping_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(WordsServer).Ping(ctx, req.(*emptypb.Empty))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Words_Norm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(WordsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(WordsServer).Norm(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Words_Norm_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(WordsServer).Norm(ctx, req.(*WordsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// Words_ServiceDesc is the grpc.ServiceDesc for Words service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Words_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "words.Words",
        HandlerType: (*WordsServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Ping",
                        Handler:    _Words_Ping_Handler,
                },
                {
                        MethodName: "Norm",
                        Handler:    _Words_Norm_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "proto/words/words.proto",
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.5
//         protoc        v6.30.0--rc1
// source: yolo/yolo.proto

package yolo

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type DetectRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        ImageData     []byte                 `protobuf:"bytes,1,opt,name=image_data,json=imageData,proto3" json:"image_data,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *DetectRequest) Reset() <span class="cov0" title="0">{
        *x = DetectRequest{}
        mi := &amp;file_yolo_yolo_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DetectRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DetectRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DetectRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_yolo_yolo_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DetectRequest.ProtoReflect.Descriptor instead.
func (*DetectRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_yolo_yolo_proto_rawDescGZIP(), []int{0}
}</span>

func (x *DetectRequest) GetImageData() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ImageData
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type DetectResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Results       []*Detection           `protobuf:"bytes,1,rep,name=results,proto3" json:"results,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *DetectResponse) Reset() <span class="cov0" title="0">{
        *x = DetectResponse{}
        mi := &amp;file_yolo_yolo_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DetectResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DetectResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DetectResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_yolo_yolo_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DetectResponse.ProtoReflect.Descriptor instead.
func (*DetectResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_yolo_yolo_proto_rawDescGZIP(), []int{1}
}</span>

func (x *DetectResponse) GetResults() []*Detection <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Results
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Detection struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Bbox          []float32              `protobuf:"fixed32,1,rep,packed,name=bbox,proto3" json:"bbox,omitempty"`
        Confidence    float32                `protobuf:"fixed32,2,opt,name=confidence,proto3" json:"confidence,omitempty"`
        Label         string                 `protobuf:"bytes,3,opt,name=label,proto3" json:"label,omitempty"`
        LabelNum      int32                  `protobuf:"varint,4,opt,name=label_num,json=labelNum,proto3" json:"label_num,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Detection) Reset() <span class="cov0" title="0">{
        *x = Detection{}
        mi := &amp;file_yolo_yolo_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Detection) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Detection) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Detection) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_yolo_yolo_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Detection.ProtoReflect.Descriptor instead.
func (*Detection) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_yolo_yolo_proto_rawDescGZIP(), []int{2}
}</span>

func (x *Detection) GetBbox() []float32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Bbox
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Detection) GetConfidence() float32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Confidence
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Detection) GetLabel() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Label
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Detection) GetLabelNum() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LabelNum
        }</span>
        <span class="cov0" title="0">return 0</span>
}

var File_yolo_yolo_proto protoreflect.FileDescriptor

var file_yolo_yolo_proto_rawDesc = string([]byte{
        0x0a, 0x0f, 0x79, 0x6f, 0x6c, 0x6f, 0x2f, 0x79, 0x6f, 0x6c, 0x6f, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x12, 0x04, 0x79, 0x6f, 0x6c, 0x6f, 0x22, 0x2e, 0x0a, 0x0d, 0x44, 0x65, 0x74, 0x65, 0x63,
        0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x69, 0x6d, 0x61, 0x67,
        0x65, 0x5f, 0x64, 0x61, 0x74, 0x61, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x09, 0x69, 0x6d,
        0x61, 0x67, 0x65, 0x44, 0x61, 0x74, 0x61, 0x22, 0x3b, 0x0a, 0x0e, 0x44, 0x65, 0x74, 0x65, 0x63,
        0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x29, 0x0a, 0x07, 0x72, 0x65, 0x73,
        0x75, 0x6c, 0x74, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x79, 0x6f, 0x6c,
        0x6f, 0x2e, 0x44, 0x65, 0x74, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x07, 0x72, 0x65, 0x73,
        0x75, 0x6c, 0x74, 0x73, 0x22, 0x72, 0x0a, 0x09, 0x44, 0x65, 0x74, 0x65, 0x63, 0x74, 0x69, 0x6f,
        0x6e, 0x12, 0x12, 0x0a, 0x04, 0x62, 0x62, 0x6f, 0x78, 0x18, 0x01, 0x20, 0x03, 0x28, 0x02, 0x52,
        0x04, 0x62, 0x62, 0x6f, 0x78, 0x12, 0x1e, 0x0a, 0x0a, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x64, 0x65,
        0x6e, 0x63, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x02, 0x52, 0x0a, 0x63, 0x6f, 0x6e, 0x66, 0x69,
        0x64, 0x65, 0x6e, 0x63, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x18, 0x03,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x12, 0x1b, 0x0a, 0x09, 0x6c,
        0x61, 0x62, 0x65, 0x6c, 0x5f, 0x6e, 0x75, 0x6d, 0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x52, 0x08,
        0x6c, 0x61, 0x62, 0x65, 0x6c, 0x4e, 0x75, 0x6d, 0x32, 0x42, 0x0a, 0x0b, 0x59, 0x6f, 0x6c, 0x6f,
        0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x33, 0x0a, 0x06, 0x44, 0x65, 0x74, 0x65, 0x63,
        0x74, 0x12, 0x13, 0x2e, 0x79, 0x6f, 0x6c, 0x6f, 0x2e, 0x44, 0x65, 0x74, 0x65, 0x63, 0x74, 0x52,
        0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x14, 0x2e, 0x79, 0x6f, 0x6c, 0x6f, 0x2e, 0x44, 0x65,
        0x74, 0x65, 0x63, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x42, 0x1d, 0x5a, 0x1b,
        0x79, 0x61, 0x64, 0x72, 0x6f, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x63, 0x6f, 0x75, 0x72, 0x73, 0x65,
        0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x79, 0x6f, 0x6c, 0x6f, 0x62, 0x06, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x33,
})

var (
        file_yolo_yolo_proto_rawDescOnce sync.Once
        file_yolo_yolo_proto_rawDescData []byte
)

func file_yolo_yolo_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_yolo_yolo_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_yolo_yolo_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_yolo_yolo_proto_rawDesc), len(file_yolo_yolo_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_yolo_yolo_proto_rawDescData</span>
}

var file_yolo_yolo_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
var file_yolo_yolo_proto_goTypes = []any{
        (*DetectRequest)(nil),  // 0: yolo.DetectRequest
        (*DetectResponse)(nil), // 1: yolo.DetectResponse
        (*Detection)(nil),      // 2: yolo.Detection
}
var file_yolo_yolo_proto_depIdxs = []int32{
        2, // 0: yolo.DetectResponse.results:type_name -&gt; yolo.Detection
        0, // 1: yolo.YoloService.Detect:input_type -&gt; yolo.DetectRequest
        1, // 2: yolo.YoloService.Detect:output_type -&gt; yolo.DetectResponse
        2, // [2:3] is the sub-list for method output_type
        1, // [1:2] is the sub-list for method input_type
        1, // [1:1] is the sub-list for extension type_name
        1, // [1:1] is the sub-list for extension extendee
        0, // [0:1] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_yolo_yolo_proto_init() }</span>
func file_yolo_yolo_proto_init() <span class="cov0" title="0">{
        if File_yolo_yolo_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_yolo_yolo_proto_rawDesc), len(file_yolo_yolo_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   3,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_yolo_yolo_proto_goTypes,
                DependencyIndexes: file_yolo_yolo_proto_depIdxs,
                MessageInfos:      file_yolo_yolo_proto_msgTypes,
        }.Build()
        File_yolo_yolo_proto = out.File
        file_yolo_yolo_proto_goTypes = nil
        file_yolo_yolo_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.30.0--rc1
// source: yolo/yolo.proto

package yolo

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        YoloService_Detect_FullMethodName = "/yolo.YoloService/Detect"
)

// YoloServiceClient is the client API for YoloService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type YoloServiceClient interface {
        Detect(ctx context.Context, in *DetectRequest, opts ...grpc.CallOption) (*DetectResponse, error)
}

type yoloServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewYoloServiceClient(cc grpc.ClientConnInterface) YoloServiceClient <span class="cov0" title="0">{
        return &amp;yoloServiceClient{cc}
}</span>

func (c *yoloServiceClient) Detect(ctx context.Context, in *DetectRequest, opts ...grpc.CallOption) (*DetectResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(DetectResponse)
        err := c.cc.Invoke(ctx, YoloService_Detect_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// YoloServiceServer is the server API for YoloService service.
// All implementations must embed UnimplementedYoloServiceServer
// for forward compatibility.
type YoloServiceServer interface {
        Detect(context.Context, *DetectRequest) (*DetectResponse, error)
        mustEmbedUnimplementedYoloServiceServer()
}

// UnimplementedYoloServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedYoloServiceServer struct{}

func (UnimplementedYoloServiceServer) Detect(context.Context, *DetectRequest) (*DetectResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Detect not implemented")
}</span>
func (UnimplementedYoloServiceServer) mustEmbedUnimplementedYoloServiceServer() {<span class="cov0" title="0">}</span>
func (UnimplementedYoloServiceServer) testEmbeddedByValue()                     {<span class="cov0" title="0">}</span>

// UnsafeYoloServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to YoloServiceServer will
// result in compilation errors.
type UnsafeYoloServiceServer interface {
        mustEmbedUnimplementedYoloServiceServer()
}

func RegisterYoloServiceServer(s grpc.ServiceRegistrar, srv YoloServiceServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedYoloServiceServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;YoloService_ServiceDesc, srv)</span>
}

func _YoloService_Detect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(DetectRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(YoloServiceServer).Detect(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: YoloService_Detect_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(YoloServiceServer).Detect(ctx, req.(*DetectRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// YoloService_ServiceDesc is the grpc.ServiceDesc for YoloService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var YoloService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "yolo.YoloService",
        HandlerType: (*YoloServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Detect",
                        Handler:    _YoloService_Detect_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "yolo/yolo.proto",
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package db

import (
        "context"
        "fmt"
        "log/slog"

        _ "github.com/jackc/pgx/v5/stdlib"
        "github.com/jmoiron/sqlx"
        "github.com/lib/pq"
        "yadro.com/course/search/core"
)

type DB struct {
        log  *slog.Logger
        conn *sqlx.DB
}

func New(log *slog.Logger, address string) (*DB, error) <span class="cov1" title="1">{
        db, err := sqlx.Connect("pgx", address)
        if err != nil </span><span class="cov1" title="1">{
                log.Error("connection problem", "address", address, "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;DB{
                log:  log,
                conn: db,
        }, nil</span>
}

func (s *DB) SearchComics(ctx context.Context, words []string, limit int) ([]core.Comics, error) <span class="cov1" title="1">{
        var comics []core.Comics
        err := s.conn.SelectContext(ctx, &amp;comics, `
        WITH search_words AS (
            SELECT unnest($1::text[]) AS word
        ),
        comic_matches AS (
            SELECT 
                c.id,
                c.url,
                -- Количество уникальных совпадающих слов
                COUNT(DISTINCT sw.word) AS unique_matches,
                -- Общее количество совпадений (с учетом частоты)
                SUM(
                    (SELECT COUNT(*) 
                     FROM unnest(c.words) AS comic_word 
                     WHERE comic_word = sw.word)
                ) AS total_matches
            FROM 
                comics c
            CROSS JOIN 
                search_words sw
            WHERE 
                c.words &amp;&amp; $1
            GROUP BY 
                c.id, c.url
        )
        SELECT 
            id,
            url
        FROM 
            comic_matches
        ORDER BY
            -- Приоритет 1: комиксы с наибольшим количеством уникальных совпадений
            unique_matches DESC,
            -- Приоритет 2: комиксы с наибольшим абсолютным количеством совпадений
            total_matches DESC
        LIMIT $2
    `, pq.Array(words), limit)

        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to search comics: %w", err)
        }</span>
        <span class="cov0" title="0">return comics, nil</span>
}

func (s *DB) Stats(ctx context.Context) (core.DBStats, error) <span class="cov6" title="2">{
        var stats core.DBStats

        if err := s.conn.GetContext(ctx, &amp;stats.WordsTotal, `
                SELECT COALESCE(SUM(array_length(words, 1)), 0) FROM comics
        `); err != nil </span><span class="cov1" title="1">{
                return core.DBStats{}, fmt.Errorf("failed to get words total: %w", err)
        }</span>

        <span class="cov1" title="1">if err := s.conn.GetContext(ctx, &amp;stats.WordsUnique, `
                SELECT COALESCE(COUNT(DISTINCT word), 0)
                FROM comics, unnest(words) AS word
        `); err != nil </span><span class="cov0" title="0">{
                return core.DBStats{}, fmt.Errorf("failed to get unique words: %w", err)
        }</span>

        <span class="cov1" title="1">if err := s.conn.GetContext(ctx, &amp;stats.ComicsFetched, `
                SELECT COUNT(*) FROM comics
        `); err != nil </span><span class="cov0" title="0">{
                return core.DBStats{}, fmt.Errorf("failed to get comics fetched: %w", err)
        }</span>

        <span class="cov1" title="1">return stats, nil</span>
}

func (s *DB) AllComics(ctx context.Context) ([]core.Comics, error) <span class="cov6" title="2">{
        var dbComics []struct {
                ID    int            `db:"id"`
                URL   string         `db:"url"`
                Words pq.StringArray `db:"words"`
        }

        err := s.conn.SelectContext(ctx, &amp;dbComics, `
        SELECT id, url, words 
        FROM comics
        ORDER BY id
    `)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch all comics: %w", err)
        }</span>

        <span class="cov6" title="2">comics := make([]core.Comics, len(dbComics))
        for i, c := range dbComics </span><span class="cov6" title="2">{
                comics[i] = core.Comics{
                        ID:    c.ID,
                        URL:   c.URL,
                        Words: []string(c.Words),
                }
        }</span>

        <span class="cov6" title="2">return comics, nil</span>
}

func (s *DB) Ping(ctx context.Context) error <span class="cov1" title="1">{
        return s.conn.PingContext(ctx)
}</span>

func (s *DB) GetComicsByIDs(ctx context.Context, ids []int) ([]core.Comics, error) <span class="cov10" title="3">{
        if len(ids) == 0 </span><span class="cov1" title="1">{
                return []core.Comics{}, nil
        }</span>

        <span class="cov6" title="2">var rawComics []struct {
                ID    int            `db:"id"`
                URL   string         `db:"url"`
                Words pq.StringArray `db:"words"`
        }

        query := `
        SELECT id, url, words 
        FROM comics 
        WHERE id = ANY($1)
    `
        err := s.conn.SelectContext(ctx, &amp;rawComics, query, pq.Array(ids))
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get comics: %w", err)
        }</span>

        <span class="cov1" title="1">comics := make([]core.Comics, len(rawComics))
        for i, raw := range rawComics </span><span class="cov1" title="1">{
                comics[i] = core.Comics{
                        ID:    raw.ID,
                        URL:   raw.URL,
                        Words: []string(raw.Words),
                }
        }</span>

        <span class="cov1" title="1">return comics, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: search/core/ports.go

// Package mock_core is a generated GoMock package.
package mock

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        core "yadro.com/course/search/core"
)

// MockSearcher is a mock of Searcher interface.
type MockSearcher struct {
        ctrl     *gomock.Controller
        recorder *MockSearcherMockRecorder
}

// MockSearcherMockRecorder is the mock recorder for MockSearcher.
type MockSearcherMockRecorder struct {
        mock *MockSearcher
}

// NewMockSearcher creates a new mock instance.
func NewMockSearcher(ctrl *gomock.Controller) *MockSearcher <span class="cov10" title="7">{
        mock := &amp;MockSearcher{ctrl: ctrl}
        mock.recorder = &amp;MockSearcherMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSearcher) EXPECT() *MockSearcherMockRecorder <span class="cov8" title="5">{
        return m.recorder
}</span>

// IndexSearch mocks base method.
func (m *MockSearcher) IndexSearch(ctx context.Context, phrase string, limit int) (core.SearchResult, error) <span class="cov4" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "IndexSearch", ctx, phrase, limit)
        ret0, _ := ret[0].(core.SearchResult)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// IndexSearch indicates an expected call of IndexSearch.
func (mr *MockSearcherMockRecorder) IndexSearch(ctx, phrase, limit interface{}) *gomock.Call <span class="cov4" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IndexSearch", reflect.TypeOf((*MockSearcher)(nil).IndexSearch), ctx, phrase, limit)
}</span>

// Search mocks base method.
func (m *MockSearcher) Search(ctx context.Context, phrase string, limit int) (core.SearchResult, error) <span class="cov6" title="3">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Search", ctx, phrase, limit)
        ret0, _ := ret[0].(core.SearchResult)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Search indicates an expected call of Search.
func (mr *MockSearcherMockRecorder) Search(ctx, phrase, limit interface{}) *gomock.Call <span class="cov6" title="3">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Search", reflect.TypeOf((*MockSearcher)(nil).Search), ctx, phrase, limit)
}</span>

// MockIndexer is a mock of Indexer interface.
type MockIndexer struct {
        ctrl     *gomock.Controller
        recorder *MockIndexerMockRecorder
}

// MockIndexerMockRecorder is the mock recorder for MockIndexer.
type MockIndexerMockRecorder struct {
        mock *MockIndexer
}

// NewMockIndexer creates a new mock instance.
func NewMockIndexer(ctrl *gomock.Controller) *MockIndexer <span class="cov0" title="0">{
        mock := &amp;MockIndexer{ctrl: ctrl}
        mock.recorder = &amp;MockIndexerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIndexer) EXPECT() *MockIndexerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// BuildIndex mocks base method.
func (m *MockIndexer) BuildIndex(ctx context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "BuildIndex", ctx)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// BuildIndex indicates an expected call of BuildIndex.
func (mr *MockIndexerMockRecorder) BuildIndex(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BuildIndex", reflect.TypeOf((*MockIndexer)(nil).BuildIndex), ctx)
}</span>

// GetIndex mocks base method.
func (m *MockIndexer) GetIndex(ctx context.Context) core.Index <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetIndex", ctx)
        ret0, _ := ret[0].(core.Index)
        return ret0
}</span>

// GetIndex indicates an expected call of GetIndex.
func (mr *MockIndexerMockRecorder) GetIndex(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetIndex", reflect.TypeOf((*MockIndexer)(nil).GetIndex), ctx)
}</span>

// MockDB is a mock of DB interface.
type MockDB struct {
        ctrl     *gomock.Controller
        recorder *MockDBMockRecorder
}

// MockDBMockRecorder is the mock recorder for MockDB.
type MockDBMockRecorder struct {
        mock *MockDB
}

// NewMockDB creates a new mock instance.
func NewMockDB(ctrl *gomock.Controller) *MockDB <span class="cov0" title="0">{
        mock := &amp;MockDB{ctrl: ctrl}
        mock.recorder = &amp;MockDBMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDB) EXPECT() *MockDBMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// AllComics mocks base method.
func (m *MockDB) AllComics(ctx context.Context) ([]core.Comics, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AllComics", ctx)
        ret0, _ := ret[0].([]core.Comics)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// AllComics indicates an expected call of AllComics.
func (mr *MockDBMockRecorder) AllComics(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AllComics", reflect.TypeOf((*MockDB)(nil).AllComics), ctx)
}</span>

// GetComicsByIDs mocks base method.
func (m *MockDB) GetComicsByIDs(ctx context.Context, ids []int) ([]core.Comics, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetComicsByIDs", ctx, ids)
        ret0, _ := ret[0].([]core.Comics)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetComicsByIDs indicates an expected call of GetComicsByIDs.
func (mr *MockDBMockRecorder) GetComicsByIDs(ctx, ids interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetComicsByIDs", reflect.TypeOf((*MockDB)(nil).GetComicsByIDs), ctx, ids)
}</span>

// SearchComics mocks base method.
func (m *MockDB) SearchComics(ctx context.Context, words []string, limit int) ([]core.Comics, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SearchComics", ctx, words, limit)
        ret0, _ := ret[0].([]core.Comics)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// SearchComics indicates an expected call of SearchComics.
func (mr *MockDBMockRecorder) SearchComics(ctx, words, limit interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SearchComics", reflect.TypeOf((*MockDB)(nil).SearchComics), ctx, words, limit)
}</span>

// Stats mocks base method.
func (m *MockDB) Stats(ctx context.Context) (core.DBStats, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Stats", ctx)
        ret0, _ := ret[0].(core.DBStats)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Stats indicates an expected call of Stats.
func (mr *MockDBMockRecorder) Stats(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stats", reflect.TypeOf((*MockDB)(nil).Stats), ctx)
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package grpc

import (
        "context"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/emptypb"
        searchpb "yadro.com/course/proto/search"
        "yadro.com/course/search/core"
)

func NewServer(service core.Searcher) *Server <span class="cov10" title="7">{
        return &amp;Server{service: service}
}</span>

type Server struct {
        searchpb.UnimplementedSearchServer
        service core.Searcher
}

func (s *Server) Search(ctx context.Context, req *searchpb.SearchRequest) (*searchpb.SearchResponse, error) <span class="cov6" title="3">{
        result, err := s.service.Search(ctx, req.Phrase, int(req.Limit))
        if err != nil </span><span class="cov1" title="1">{
                return nil, status.Error(codes.Internal, err.Error())
        }</span>

        <span class="cov4" title="2">var comics []*searchpb.Comic
        for _, comic := range result.Comics </span><span class="cov4" title="2">{
                comics = append(comics, &amp;searchpb.Comic{
                        Id:  int32(comic.ID),
                        Url: comic.URL,
                })
        }</span>

        <span class="cov4" title="2">return &amp;searchpb.SearchResponse{
                Comics: comics,
                Total:  int32(result.Total),
        }, nil</span>
}

func (s *Server) IndexSearch(ctx context.Context, req *searchpb.IndexSearchRequest) (*searchpb.SearchResponse, error) <span class="cov4" title="2">{
        result, err := s.service.IndexSearch(ctx, req.Phrase, int(req.Limit))
        if err != nil </span><span class="cov1" title="1">{
                return nil, status.Error(codes.Internal, err.Error())
        }</span>

        <span class="cov1" title="1">var comics []*searchpb.Comic
        for _, comic := range result.Comics </span><span class="cov1" title="1">{
                comics = append(comics, &amp;searchpb.Comic{
                        Id:  int32(comic.ID),
                        Url: comic.URL,
                })
        }</span>
        <span class="cov1" title="1">return &amp;searchpb.SearchResponse{
                Comics: comics,
                Total:  int32(result.Total),
        }, nil</span>
}

func (s *Server) Ping(ctx context.Context, _ *emptypb.Empty) (*emptypb.Empty, error) <span class="cov1" title="1">{
        return &amp;emptypb.Empty{}, nil
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package initiator

import (
        "context"
        "log/slog"
        "time"

        "yadro.com/course/search/core"
)

type Initiator struct {
        log     *slog.Logger
        service core.Indexer
        ttl     time.Duration
}

func NewInit(log *slog.Logger, service core.Indexer, ttl time.Duration) *Initiator <span class="cov10" title="6">{
        return &amp;Initiator{log: log, service: service, ttl: ttl}
}</span>

func (i *Initiator) Start(ctx context.Context) <span class="cov1" title="1">{
        i.buildIndex(ctx)

        ticker := time.NewTicker(i.ttl)
        defer ticker.Stop()

        for </span><span class="cov1" title="1">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        i.buildIndex(ctx)</span>
                case &lt;-ctx.Done():<span class="cov1" title="1">
                        i.log.Info("Initiator stopped")
                        return</span>
                }
        }
}

func (i *Initiator) buildIndex(ctx context.Context) <span class="cov9" title="5">{
        i.log.Info("Building index...")
        if err := i.service.BuildIndex(ctx); err != nil </span><span class="cov6" title="3">{
                i.log.Error("Index build failed", "error", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: search/core/ports.go

// Package mock_core is a generated GoMock package.
package mock_core

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        core "yadro.com/course/search/core"
)

// MockIndexer is a mock of Indexer interface.
type MockIndexer struct {
        ctrl     *gomock.Controller
        recorder *MockIndexerMockRecorder
}

// MockIndexerMockRecorder is the mock recorder for MockIndexer.
type MockIndexerMockRecorder struct {
        mock *MockIndexer
}

// NewMockIndexer creates a new mock instance.
func NewMockIndexer(ctrl *gomock.Controller) *MockIndexer <span class="cov10" title="6">{
        mock := &amp;MockIndexer{ctrl: ctrl}
        mock.recorder = &amp;MockIndexerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIndexer) EXPECT() *MockIndexerMockRecorder <span class="cov9" title="5">{
        return m.recorder
}</span>

// BuildIndex mocks base method.
func (m *MockIndexer) BuildIndex(ctx context.Context) error <span class="cov9" title="5">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "BuildIndex", ctx)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// BuildIndex indicates an expected call of BuildIndex.
func (mr *MockIndexerMockRecorder) BuildIndex(ctx interface{}) *gomock.Call <span class="cov9" title="5">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BuildIndex", reflect.TypeOf((*MockIndexer)(nil).BuildIndex), ctx)
}</span>

// GetIndex mocks base method.
func (m *MockIndexer) GetIndex(ctx context.Context) core.Index <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetIndex", ctx)
        ret0, _ := ret[0].(core.Index)
        return ret0
}</span>

// GetIndex indicates an expected call of GetIndex.
func (mr *MockIndexerMockRecorder) GetIndex(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetIndex", reflect.TypeOf((*MockIndexer)(nil).GetIndex), ctx)
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: proto/words/words_grpc.pb.go

// Package mock_words is a generated GoMock package.
package mock_words

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        grpc "google.golang.org/grpc"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
        words "yadro.com/course/proto/words"
)

// MockWordsClient is a mock of WordsClient interface.
type MockWordsClient struct {
        ctrl     *gomock.Controller
        recorder *MockWordsClientMockRecorder
}

// MockWordsClientMockRecorder is the mock recorder for MockWordsClient.
type MockWordsClientMockRecorder struct {
        mock *MockWordsClient
}

// NewMockWordsClient creates a new mock instance.
func NewMockWordsClient(ctrl *gomock.Controller) *MockWordsClient <span class="cov4" title="2">{
        mock := &amp;MockWordsClient{ctrl: ctrl}
        mock.recorder = &amp;MockWordsClientMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWordsClient) EXPECT() *MockWordsClientMockRecorder <span class="cov10" title="5">{
        return m.recorder
}</span>

// Norm mocks base method.
func (m *MockWordsClient) Norm(ctx context.Context, in *words.WordsRequest, opts ...grpc.CallOption) (*words.WordsReply, error) <span class="cov7" title="3">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov7" title="3">ret := m.ctrl.Call(m, "Norm", varargs...)
        ret0, _ := ret[0].(*words.WordsReply)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// Norm indicates an expected call of Norm.
func (mr *MockWordsClientMockRecorder) Norm(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov7" title="3">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Norm", reflect.TypeOf((*MockWordsClient)(nil).Norm), varargs...)
}</span>

// Ping mocks base method.
func (m *MockWordsClient) Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) <span class="cov4" title="2">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov4" title="2">ret := m.ctrl.Call(m, "Ping", varargs...)
        ret0, _ := ret[0].(*emptypb.Empty)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// Ping indicates an expected call of Ping.
func (mr *MockWordsClientMockRecorder) Ping(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov4" title="2">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ping", reflect.TypeOf((*MockWordsClient)(nil).Ping), varargs...)
}</span>

// MockWordsServer is a mock of WordsServer interface.
type MockWordsServer struct {
        ctrl     *gomock.Controller
        recorder *MockWordsServerMockRecorder
}

// MockWordsServerMockRecorder is the mock recorder for MockWordsServer.
type MockWordsServerMockRecorder struct {
        mock *MockWordsServer
}

// NewMockWordsServer creates a new mock instance.
func NewMockWordsServer(ctrl *gomock.Controller) *MockWordsServer <span class="cov0" title="0">{
        mock := &amp;MockWordsServer{ctrl: ctrl}
        mock.recorder = &amp;MockWordsServerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWordsServer) EXPECT() *MockWordsServerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Norm mocks base method.
func (m *MockWordsServer) Norm(arg0 context.Context, arg1 *words.WordsRequest) (*words.WordsReply, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Norm", arg0, arg1)
        ret0, _ := ret[0].(*words.WordsReply)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Norm indicates an expected call of Norm.
func (mr *MockWordsServerMockRecorder) Norm(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Norm", reflect.TypeOf((*MockWordsServer)(nil).Norm), arg0, arg1)
}</span>

// Ping mocks base method.
func (m *MockWordsServer) Ping(arg0 context.Context, arg1 *emptypb.Empty) (*emptypb.Empty, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Ping", arg0, arg1)
        ret0, _ := ret[0].(*emptypb.Empty)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Ping indicates an expected call of Ping.
func (mr *MockWordsServerMockRecorder) Ping(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ping", reflect.TypeOf((*MockWordsServer)(nil).Ping), arg0, arg1)
}</span>

// mustEmbedUnimplementedWordsServer mocks base method.
func (m *MockWordsServer) mustEmbedUnimplementedWordsServer() <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "mustEmbedUnimplementedWordsServer")
}</span>

// mustEmbedUnimplementedWordsServer indicates an expected call of mustEmbedUnimplementedWordsServer.
func (mr *MockWordsServerMockRecorder) mustEmbedUnimplementedWordsServer() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "mustEmbedUnimplementedWordsServer", reflect.TypeOf((*MockWordsServer)(nil).mustEmbedUnimplementedWordsServer))
}</span>

// MockUnsafeWordsServer is a mock of UnsafeWordsServer interface.
type MockUnsafeWordsServer struct {
        ctrl     *gomock.Controller
        recorder *MockUnsafeWordsServerMockRecorder
}

// MockUnsafeWordsServerMockRecorder is the mock recorder for MockUnsafeWordsServer.
type MockUnsafeWordsServerMockRecorder struct {
        mock *MockUnsafeWordsServer
}

// NewMockUnsafeWordsServer creates a new mock instance.
func NewMockUnsafeWordsServer(ctrl *gomock.Controller) *MockUnsafeWordsServer <span class="cov0" title="0">{
        mock := &amp;MockUnsafeWordsServer{ctrl: ctrl}
        mock.recorder = &amp;MockUnsafeWordsServerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUnsafeWordsServer) EXPECT() *MockUnsafeWordsServerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// mustEmbedUnimplementedWordsServer mocks base method.
func (m *MockUnsafeWordsServer) mustEmbedUnimplementedWordsServer() <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "mustEmbedUnimplementedWordsServer")
}</span>

// mustEmbedUnimplementedWordsServer indicates an expected call of mustEmbedUnimplementedWordsServer.
func (mr *MockUnsafeWordsServerMockRecorder) mustEmbedUnimplementedWordsServer() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "mustEmbedUnimplementedWordsServer", reflect.TypeOf((*MockUnsafeWordsServer)(nil).mustEmbedUnimplementedWordsServer))
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package words

import (
        "context"
        "fmt"
        "log/slog"

        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
        wordspb "yadro.com/course/proto/words"
)

type Client struct {
        log    *slog.Logger
        client wordspb.WordsClient
}

func NewClient(address string, log *slog.Logger) (*Client, error) <span class="cov0" title="0">{
        conn, err := grpc.NewClient(address, grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;Client{
                client: wordspb.NewWordsClient(conn),
                log:    log,
        }, nil</span>
}

func (c Client) Norm(ctx context.Context, phrase string) ([]string, error) <span class="cov10" title="3">{
        resp, err := c.client.Norm(ctx, &amp;wordspb.WordsRequest{Phrase: phrase})
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to normalize words: %w", err)
        }</span>
        <span class="cov6" title="2">return resp.Words, nil</span>
}

func (c Client) Ping(ctx context.Context) error <span class="cov6" title="2">{
        _, err := c.client.Ping(ctx, nil)
        return err
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package config

import (
        "log"
        "time"

        "github.com/ilyakaznacheev/cleanenv"
)

type SEARCHConfig struct {
        Address  string        `yaml:"address" env:"SEARCH_ADDRESS" env-default:"localhost:80"`
        Timeout  time.Duration `yaml:"timeout" env:"SEARCH_TIMEOUT" env-default:"5s"`
        IndexTTL time.Duration `yaml:"index_ttl" env:"INDEX_TTL" env-default:"20s"`
}

type Config struct {
        LogLevel     string       `yaml:"log_level" env:"LOG_LEVEL" env-default:"DEBUG"`
        SearchConfig SEARCHConfig `yaml:"search_server"`
        DBAddress    string       `yaml:"db_address" env:"DB_ADDRESS" env-default:"postgres://user:password@localhost:5432/dbname"`
        WordsAddress string       `yaml:"words_address" env:"WORDS_ADDRESS" env-default:"localhost:50051"`
}

func MustLoad(configPath string) Config <span class="cov10" title="3">{
        var cfg Config

        if err := cleanenv.ReadConfig(configPath, &amp;cfg); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("cannot read config: %s", err)
        }</span>

        <span class="cov10" title="3">return cfg</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: search/core/ports.go

// Package mock_core is a generated GoMock package.
package core

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockSearcher is a mock of Searcher interface.
type MockSearcher struct {
        ctrl     *gomock.Controller
        recorder *MockSearcherMockRecorder
}

// MockSearcherMockRecorder is the mock recorder for MockSearcher.
type MockSearcherMockRecorder struct {
        mock *MockSearcher
}

// NewMockSearcher creates a new mock instance.
func NewMockSearcher(ctrl *gomock.Controller) *MockSearcher <span class="cov0" title="0">{
        mock := &amp;MockSearcher{ctrl: ctrl}
        mock.recorder = &amp;MockSearcherMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSearcher) EXPECT() *MockSearcherMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// IndexSearch mocks base method.
func (m *MockSearcher) IndexSearch(ctx context.Context, phrase string, limit int) (SearchResult, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "IndexSearch", ctx, phrase, limit)
        ret0, _ := ret[0].(SearchResult)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// IndexSearch indicates an expected call of IndexSearch.
func (mr *MockSearcherMockRecorder) IndexSearch(ctx, phrase, limit interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IndexSearch", reflect.TypeOf((*MockSearcher)(nil).IndexSearch), ctx, phrase, limit)
}</span>

// Search mocks base method.
func (m *MockSearcher) Search(ctx context.Context, phrase string, limit int) (SearchResult, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Search", ctx, phrase, limit)
        ret0, _ := ret[0].(SearchResult)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Search indicates an expected call of Search.
func (mr *MockSearcherMockRecorder) Search(ctx, phrase, limit interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Search", reflect.TypeOf((*MockSearcher)(nil).Search), ctx, phrase, limit)
}</span>

// MockIndexer is a mock of Indexer interface.
type MockIndexer struct {
        ctrl     *gomock.Controller
        recorder *MockIndexerMockRecorder
}

// MockIndexerMockRecorder is the mock recorder for MockIndexer.
type MockIndexerMockRecorder struct {
        mock *MockIndexer
}

// NewMockIndexer creates a new mock instance.
func NewMockIndexer(ctrl *gomock.Controller) *MockIndexer <span class="cov0" title="0">{
        mock := &amp;MockIndexer{ctrl: ctrl}
        mock.recorder = &amp;MockIndexerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIndexer) EXPECT() *MockIndexerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// BuildIndex mocks base method.
func (m *MockIndexer) BuildIndex(ctx context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "BuildIndex", ctx)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// BuildIndex indicates an expected call of BuildIndex.
func (mr *MockIndexerMockRecorder) BuildIndex(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BuildIndex", reflect.TypeOf((*MockIndexer)(nil).BuildIndex), ctx)
}</span>

// GetIndex mocks base method.
func (m *MockIndexer) GetIndex(ctx context.Context) Index <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetIndex", ctx)
        ret0, _ := ret[0].(Index)
        return ret0
}</span>

// GetIndex indicates an expected call of GetIndex.
func (mr *MockIndexerMockRecorder) GetIndex(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetIndex", reflect.TypeOf((*MockIndexer)(nil).GetIndex), ctx)
}</span>

// MockDB is a mock of DB interface.
type MockDB struct {
        ctrl     *gomock.Controller
        recorder *MockDBMockRecorder
}

// MockDBMockRecorder is the mock recorder for MockDB.
type MockDBMockRecorder struct {
        mock *MockDB
}

// NewMockDB creates a new mock instance.
func NewMockDB(ctrl *gomock.Controller) *MockDB <span class="cov8" title="5">{
        mock := &amp;MockDB{ctrl: ctrl}
        mock.recorder = &amp;MockDBMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDB) EXPECT() *MockDBMockRecorder <span class="cov10" title="7">{
        return m.recorder
}</span>

// AllComics mocks base method.
func (m *MockDB) AllComics(ctx context.Context) ([]Comics, error) <span class="cov4" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AllComics", ctx)
        ret0, _ := ret[0].([]Comics)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// AllComics indicates an expected call of AllComics.
func (mr *MockDBMockRecorder) AllComics(ctx interface{}) *gomock.Call <span class="cov4" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AllComics", reflect.TypeOf((*MockDB)(nil).AllComics), ctx)
}</span>

// GetComicsByIDs mocks base method.
func (m *MockDB) GetComicsByIDs(ctx context.Context, ids []int) ([]Comics, error) <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetComicsByIDs", ctx, ids)
        ret0, _ := ret[0].([]Comics)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetComicsByIDs indicates an expected call of GetComicsByIDs.
func (mr *MockDBMockRecorder) GetComicsByIDs(ctx, ids interface{}) *gomock.Call <span class="cov1" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetComicsByIDs", reflect.TypeOf((*MockDB)(nil).GetComicsByIDs), ctx, ids)
}</span>

// SearchComics mocks base method.
func (m *MockDB) SearchComics(ctx context.Context, words []string, limit int) ([]Comics, error) <span class="cov4" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SearchComics", ctx, words, limit)
        ret0, _ := ret[0].([]Comics)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// SearchComics indicates an expected call of SearchComics.
func (mr *MockDBMockRecorder) SearchComics(ctx, words, limit interface{}) *gomock.Call <span class="cov4" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SearchComics", reflect.TypeOf((*MockDB)(nil).SearchComics), ctx, words, limit)
}</span>

// Stats mocks base method.
func (m *MockDB) Stats(ctx context.Context) (DBStats, error) <span class="cov4" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Stats", ctx)
        ret0, _ := ret[0].(DBStats)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Stats indicates an expected call of Stats.
func (mr *MockDBMockRecorder) Stats(ctx interface{}) *gomock.Call <span class="cov4" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stats", reflect.TypeOf((*MockDB)(nil).Stats), ctx)
}</span>

// MockWords is a mock of Words interface.
type MockWords struct {
        ctrl     *gomock.Controller
        recorder *MockWordsMockRecorder
}

// MockWordsMockRecorder is the mock recorder for MockWords.
type MockWordsMockRecorder struct {
        mock *MockWords
}

// NewMockWords creates a new mock instance.
func NewMockWords(ctrl *gomock.Controller) *MockWords <span class="cov8" title="5">{
        mock := &amp;MockWords{ctrl: ctrl}
        mock.recorder = &amp;MockWordsMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWords) EXPECT() *MockWordsMockRecorder <span class="cov8" title="5">{
        return m.recorder
}</span>

// Norm mocks base method.
func (m *MockWords) Norm(ctx context.Context, phrase string) ([]string, error) <span class="cov8" title="5">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Norm", ctx, phrase)
        ret0, _ := ret[0].([]string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Norm indicates an expected call of Norm.
func (mr *MockWordsMockRecorder) Norm(ctx, phrase interface{}) *gomock.Call <span class="cov8" title="5">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Norm", reflect.TypeOf((*MockWords)(nil).Norm), ctx, phrase)
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package core

import (
        "context"
        "fmt"
        "log/slog"
        "sort"
        "sync"
)

type Service struct {
        log   *slog.Logger
        db    DB
        words Words
        index Index
        mu    sync.RWMutex
}

func NewService(log *slog.Logger, db DB, words Words) (*Service, error) <span class="cov7" title="5">{
        return &amp;Service{
                log:   log,
                db:    db,
                words: words,
                index: make(Index),
        }, nil
}</span>

func (s *Service) Search(ctx context.Context, phrase string, limit int) (SearchResult, error) <span class="cov5" title="3">{
        words, err := s.words.Norm(ctx, phrase)
        if err != nil </span><span class="cov1" title="1">{
                return SearchResult{}, fmt.Errorf("normalization failed: %w", err)
        }</span>

        <span class="cov4" title="2">allComics, err := s.db.SearchComics(ctx, words, limit)
        if err != nil </span><span class="cov1" title="1">{
                return SearchResult{}, fmt.Errorf("db search failed: %w", err)
        }</span>

        <span class="cov1" title="1">resultComics := allComics
        if limit &gt; 0 &amp;&amp; len(allComics) &gt; limit </span><span class="cov0" title="0">{
                resultComics = allComics[:limit]
        }</span>

        <span class="cov1" title="1">return SearchResult{
                Comics: resultComics,
                Total:  len(allComics),
        }, nil</span>
}

func (s *Service) IndexSearch(ctx context.Context, phrase string, limit int) (SearchResult, error) <span class="cov4" title="2">{
        words, err := s.words.Norm(ctx, phrase)
        if err != nil </span><span class="cov1" title="1">{
                return SearchResult{}, err
        }</span>

        <span class="cov1" title="1">s.mu.RLock()
        defer s.mu.RUnlock()

        idSet := make(map[int]struct{})
        wordToIds := make(map[string]map[int]struct{})

        for _, word := range words </span><span class="cov4" title="2">{
                if ids, exists := s.index[word]; exists </span><span class="cov4" title="2">{
                        wordToIds[word] = make(map[int]struct{})
                        for _, id := range ids </span><span class="cov7" title="4">{
                                wordToIds[word][id] = struct{}{}
                                idSet[id] = struct{}{}
                        }</span>
                }
        }

        <span class="cov1" title="1">ids := make([]int, 0, len(idSet))
        for id := range idSet </span><span class="cov5" title="3">{
                ids = append(ids, id)
        }</span>

        <span class="cov1" title="1">comics, err := s.db.GetComicsByIDs(ctx, ids)
        if err != nil </span><span class="cov0" title="0">{
                return SearchResult{}, err
        }</span>

        <span class="cov1" title="1">sort.Slice(comics, func(i, j int) bool </span><span class="cov4" title="2">{
                iUnique, iTotal := countMatches(comics[i].ID, comics[i].Words, words, wordToIds)
                jUnique, jTotal := countMatches(comics[j].ID, comics[j].Words, words, wordToIds)

                // Сначала комиксы с большим количеством уникальных совпадений
                if iUnique != jUnique </span><span class="cov1" title="1">{
                        return iUnique &gt; jUnique
                }</span>
                // Затем по общему количеству совпадений
                <span class="cov1" title="1">return iTotal &gt; jTotal</span>
        })

        <span class="cov1" title="1">if limit &gt; 0 &amp;&amp; len(comics) &gt; limit </span><span class="cov0" title="0">{
                comics = comics[:limit]
        }</span>

        <span class="cov1" title="1">return SearchResult{Comics: comics, Total: len(comics)}, nil</span>
}

func countMatches(id int, comicWords, searchWords []string, wordToIds map[string]map[int]struct{}) (int, int) <span class="cov7" title="4">{
        uniqueMatches := 0
        totalMatches := 0

        comicWordCount := make(map[string]int)
        for _, word := range comicWords </span><span class="cov7" title="5">{
                comicWordCount[word]++
        }</span>

        <span class="cov7" title="4">for _, word := range searchWords </span><span class="cov10" title="8">{
                if ids, exists := wordToIds[word]; exists </span><span class="cov10" title="8">{
                        if _, hasWord := ids[id]; hasWord </span><span class="cov7" title="5">{
                                uniqueMatches++
                                totalMatches += comicWordCount[word]
                        }</span>
                }
        }

        <span class="cov7" title="4">return uniqueMatches, totalMatches</span>
}

func (s *Service) GetIndex(ctx context.Context) Index <span class="cov1" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.index
}</span>

func (s *Service) BuildIndex(ctx context.Context) error <span class="cov4" title="2">{
        comics, err := s.db.AllComics(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to get comics: %w", err)
        }</span>

        <span class="cov1" title="1">newIndex := make(Index)
        for _, comic := range comics </span><span class="cov5" title="3">{
                for _, word := range comic.Words </span><span class="cov7" title="5">{
                        newIndex[word] = append(newIndex[word], comic.ID)
                }</span>
        }

        <span class="cov1" title="1">s.mu.RLock()
        s.index = newIndex
        s.mu.RUnlock()

        s.log.Info("Index rebuilt",
                "total_comics", len(comics),
                "unique_words", len(newIndex))

        return nil</span>
}

func (s *Service) Stats(ctx context.Context) (DBStats, error) <span class="cov4" title="2">{
        return s.db.Stats(ctx)
}</span>

func (s *Service) Ping(ctx context.Context) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package main

import (
        "context"
        "flag"
        "fmt"
        "log/slog"
        "net"
        "os"
        "os/signal"
        "syscall"

        "google.golang.org/grpc"
        "google.golang.org/grpc/reflection"
        searchpb "yadro.com/course/proto/search"
        "yadro.com/course/search/adapters/db"
        searchgrpc "yadro.com/course/search/adapters/grpc"
        "yadro.com/course/search/adapters/initiator"
        "yadro.com/course/search/adapters/words"
        "yadro.com/course/search/config"
        "yadro.com/course/search/core"
)

func main() <span class="cov0" title="0">{
        var configPath string
        flag.StringVar(&amp;configPath, "config", "config.yaml", "path to config file")
        flag.Parse()

        cfg := config.MustLoad(configPath)

        log := slog.New(slog.NewTextHandler(os.Stdout, &amp;slog.HandlerOptions{Level: slog.LevelDebug}))

        if err := run(cfg, log); err != nil </span><span class="cov0" title="0">{
                slog.Error("fatal error", "error", err)
                os.Exit(1)
        }</span>
}

func run(cfg config.Config, log *slog.Logger) error <span class="cov0" title="0">{
        dbAdapter, err := db.New(log, cfg.DBAddress)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("failed to connect to db", "error", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">wordsAdapter, err := words.NewClient(cfg.WordsAddress, log)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("failed to connect to words service", "error", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">service, err := core.NewService(log, dbAdapter, wordsAdapter)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to serve: %w", err)
        }</span>

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                init := initiator.NewInit(log, service, cfg.SearchConfig.IndexTTL)
                init.Start(context.Background())
        }</span>()

        <span class="cov0" title="0">listener, err := net.Listen("tcp", cfg.SearchConfig.Address)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("failed to listen", "error", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">s := grpc.NewServer()
        searchpb.RegisterSearchServer(s, searchgrpc.NewServer(service))
        reflection.Register(s)

        ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGTERM)
        defer stop()

        go func() </span><span class="cov0" title="0">{
                &lt;-ctx.Done()
                log.Info("shutting down server")
                s.GracefulStop()
        }</span>()

        <span class="cov0" title="0">log.Info("starting server", "address", cfg.SearchConfig.Address)

        if err := s.Serve(listener); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to serve: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package db

import (
        "embed"

        "github.com/golang-migrate/migrate/v4"
        "github.com/golang-migrate/migrate/v4/database/pgx"
        "github.com/golang-migrate/migrate/v4/source/iofs"
)

//go:embed migrations/*.sql
var migrationFiles embed.FS

func (db *DB) Migrate() error <span class="cov8" title="1">{
        db.log.Debug("running migration")
        files, err := iofs.New(migrationFiles, "migrations") // get migrations from
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">driver, err := pgx.WithInstance(db.conn.DB, &amp;pgx.Config{})
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov0" title="0">m, err := migrate.NewWithInstance("iofs", files, "pgx", driver)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = m.Up()

        if err != nil </span><span class="cov0" title="0">{
                if err != migrate.ErrNoChange </span><span class="cov0" title="0">{
                        db.log.Error("migration failed", "error", err)
                        return err
                }</span>
                <span class="cov0" title="0">db.log.Debug("migration did not change anything")</span>
        }

        <span class="cov0" title="0">db.log.Debug("migration finished")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package db

import (
        "context"
        "fmt"
        "log/slog"

        _ "github.com/jackc/pgx/v5/stdlib"
        "github.com/jmoiron/sqlx"
        "yadro.com/course/update/core"
)

type DB struct {
        log  *slog.Logger
        conn *sqlx.DB
}

func New(log *slog.Logger, address string) (*DB, error) <span class="cov1" title="1">{
        db, err := sqlx.Connect("pgx", address)
        if err != nil </span><span class="cov1" title="1">{
                log.Error("connection problem", "address", address, "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;DB{
                log:  log,
                conn: db,
        }, nil</span>
}

func (db *DB) Add(ctx context.Context, comics core.Comics) error <span class="cov0" title="0">{
        _, err := db.conn.ExecContext(ctx, `
                INSERT INTO comics (id, url, words) VALUES ($1, $2, $3)
                ON CONFLICT (id) DO NOTHING
        `, comics.ID, comics.URL, comics.Words)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to insert comic: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (db *DB) Stats(ctx context.Context) (core.DBStats, error) <span class="cov10" title="2">{
        var stats core.DBStats

        if err := db.conn.GetContext(ctx, &amp;stats.WordsTotal, `
        SELECT COALESCE(SUM(array_length(words, 1)), 0) FROM comics
    `); err != nil </span><span class="cov1" title="1">{
                return core.DBStats{}, fmt.Errorf("failed to get words total: %w", err)
        }</span>

        <span class="cov1" title="1">if err := db.conn.GetContext(ctx, &amp;stats.WordsUnique, `
        SELECT COALESCE(COUNT(DISTINCT word), 0)
        FROM comics, unnest(words) AS word
    `); err != nil </span><span class="cov0" title="0">{
                return core.DBStats{}, fmt.Errorf("failed to get unique words: %w", err)
        }</span>

        <span class="cov1" title="1">if err := db.conn.GetContext(ctx, &amp;stats.ComicsFetched, `SELECT COUNT(*) FROM comics`); err != nil </span><span class="cov0" title="0">{
                return core.DBStats{}, fmt.Errorf("failed to get comics fetched: %w", err)
        }</span>

        <span class="cov1" title="1">return stats, nil</span>
}

func (db *DB) IDs(ctx context.Context) ([]int, error) <span class="cov10" title="2">{
        var ids []int
        if err := db.conn.SelectContext(ctx, &amp;ids, `SELECT id FROM comics`); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get comic IDs: %w", err)
        }</span>

        <span class="cov1" title="1">return ids, nil</span>
}

func (db *DB) Drop(ctx context.Context) error <span class="cov10" title="2">{
        if _, err := db.conn.ExecContext(ctx, `DELETE FROM comics`); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to delete comics: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ports.go

// Package mocks is a generated GoMock package.
package mock_server

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        core "yadro.com/course/update/core"
)

// MockUpdater is a mock of Updater interface.
type MockUpdater struct {
        ctrl     *gomock.Controller
        recorder *MockUpdaterMockRecorder
}

// MockUpdaterMockRecorder is the mock recorder for MockUpdater.
type MockUpdaterMockRecorder struct {
        mock *MockUpdater
}

// NewMockUpdater creates a new mock instance.
func NewMockUpdater(ctrl *gomock.Controller) *MockUpdater <span class="cov10" title="12">{
        mock := &amp;MockUpdater{ctrl: ctrl}
        mock.recorder = &amp;MockUpdaterMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUpdater) EXPECT() *MockUpdaterMockRecorder <span class="cov9" title="10">{
        return m.recorder
}</span>

// Drop mocks base method.
func (m *MockUpdater) Drop(arg0 context.Context) error <span class="cov3" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Drop", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Drop indicates an expected call of Drop.
func (mr *MockUpdaterMockRecorder) Drop(arg0 interface{}) *gomock.Call <span class="cov3" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Drop", reflect.TypeOf((*MockUpdater)(nil).Drop), arg0)
}</span>

// Stats mocks base method.
func (m *MockUpdater) Stats(arg0 context.Context) (core.ServiceStats, error) <span class="cov3" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Stats", arg0)
        ret0, _ := ret[0].(core.ServiceStats)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Stats indicates an expected call of Stats.
func (mr *MockUpdaterMockRecorder) Stats(arg0 interface{}) *gomock.Call <span class="cov3" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stats", reflect.TypeOf((*MockUpdater)(nil).Stats), arg0)
}</span>

// Status mocks base method.
func (m *MockUpdater) Status(arg0 context.Context) core.ServiceStatus <span class="cov4" title="3">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Status", arg0)
        ret0, _ := ret[0].(core.ServiceStatus)
        return ret0
}</span>

// Status indicates an expected call of Status.
func (mr *MockUpdaterMockRecorder) Status(arg0 interface{}) *gomock.Call <span class="cov4" title="3">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Status", reflect.TypeOf((*MockUpdater)(nil).Status), arg0)
}</span>

// Update mocks base method.
func (m *MockUpdater) Update(arg0 context.Context) error <span class="cov4" title="3">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Update indicates an expected call of Update.
func (mr *MockUpdaterMockRecorder) Update(arg0 interface{}) *gomock.Call <span class="cov4" title="3">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockUpdater)(nil).Update), arg0)
}</span>

// MockDB is a mock of DB interface.
type MockDB struct {
        ctrl     *gomock.Controller
        recorder *MockDBMockRecorder
}

// MockDBMockRecorder is the mock recorder for MockDB.
type MockDBMockRecorder struct {
        mock *MockDB
}

// NewMockDB creates a new mock instance.
func NewMockDB(ctrl *gomock.Controller) *MockDB <span class="cov0" title="0">{
        mock := &amp;MockDB{ctrl: ctrl}
        mock.recorder = &amp;MockDBMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDB) EXPECT() *MockDBMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Add mocks base method.
func (m *MockDB) Add(arg0 context.Context, arg1 core.Comics) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Add", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Add indicates an expected call of Add.
func (mr *MockDBMockRecorder) Add(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Add", reflect.TypeOf((*MockDB)(nil).Add), arg0, arg1)
}</span>

// Drop mocks base method.
func (m *MockDB) Drop(arg0 context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Drop", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Drop indicates an expected call of Drop.
func (mr *MockDBMockRecorder) Drop(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Drop", reflect.TypeOf((*MockDB)(nil).Drop), arg0)
}</span>

// IDs mocks base method.
func (m *MockDB) IDs(arg0 context.Context) ([]int, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "IDs", arg0)
        ret0, _ := ret[0].([]int)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// IDs indicates an expected call of IDs.
func (mr *MockDBMockRecorder) IDs(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IDs", reflect.TypeOf((*MockDB)(nil).IDs), arg0)
}</span>

// Stats mocks base method.
func (m *MockDB) Stats(arg0 context.Context) (core.DBStats, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Stats", arg0)
        ret0, _ := ret[0].(core.DBStats)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Stats indicates an expected call of Stats.
func (mr *MockDBMockRecorder) Stats(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stats", reflect.TypeOf((*MockDB)(nil).Stats), arg0)
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package grpc

import (
        "context"
        "errors"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/emptypb"
        updatepb "yadro.com/course/proto/update"
        "yadro.com/course/update/core"
)

func NewServer(service core.Updater) *Server <span class="cov10" title="12">{
        return &amp;Server{service: service}
}</span>

type Server struct {
        updatepb.UnimplementedUpdateServer
        service core.Updater
}

func (s *Server) Ping(_ context.Context, _ *emptypb.Empty) (*emptypb.Empty, error) <span class="cov1" title="1">{
        return &amp;emptypb.Empty{}, nil
}</span>

func (s *Server) Status(ctx context.Context, _ *emptypb.Empty) (*updatepb.StatusReply, error) <span class="cov4" title="3">{
        stat := s.service.Status(ctx)
        return &amp;updatepb.StatusReply{
                Status: toProtoStatus(stat),
        }, nil
}</span>

func (s *Server) Update(ctx context.Context, _ *emptypb.Empty) (*emptypb.Empty, error) <span class="cov4" title="3">{
        if err := s.service.Update(ctx); err != nil </span><span class="cov3" title="2">{
                if errors.Is(err, core.ErrAlreadyExists) </span><span class="cov1" title="1">{
                        return nil, status.Error(codes.AlreadyExists, err.Error())
                }</span>
                <span class="cov1" title="1">return nil, status.Error(codes.Internal, err.Error())</span>
        }
        <span class="cov1" title="1">return &amp;emptypb.Empty{}, nil</span>
}

func (s *Server) Stats(ctx context.Context, _ *emptypb.Empty) (*updatepb.StatsReply, error) <span class="cov3" title="2">{
        stats, err := s.service.Stats(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return nil, status.Error(codes.Internal, err.Error())
        }</span>
        <span class="cov1" title="1">return &amp;updatepb.StatsReply{
                WordsTotal:    int64(stats.WordsTotal),
                WordsUnique:   int64(stats.WordsUnique),
                ComicsTotal:   int64(stats.ComicsTotal),
                ComicsFetched: int64(stats.ComicsFetched),
        }, nil</span>
}

func (s *Server) Drop(ctx context.Context, _ *emptypb.Empty) (*emptypb.Empty, error) <span class="cov3" title="2">{
        if err := s.service.Drop(ctx); err != nil </span><span class="cov1" title="1">{
                return nil, status.Error(codes.Internal, err.Error())
        }</span>
        <span class="cov1" title="1">return &amp;emptypb.Empty{}, nil</span>
}

func toProtoStatus(status core.ServiceStatus) updatepb.Status <span class="cov7" title="6">{
        switch status </span>{
        case core.StatusIdle:<span class="cov3" title="2">
                return updatepb.Status_STATUS_IDLE</span>
        case core.StatusRunning:<span class="cov3" title="2">
                return updatepb.Status_STATUS_RUNNING</span>
        default:<span class="cov3" title="2">
                return updatepb.Status_STATUS_UNSPECIFIED</span>
        }
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package mock_words

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

type MockWords struct {
        ctrl     *gomock.Controller
        recorder *MockWordsMockRecorder
}

// MockWordsMockRecorder is the mock recorder for MockWords.
type MockWordsMockRecorder struct {
        mock *MockWords
}

// NewMockWords creates a new mock instance.
func NewMockWords(ctrl *gomock.Controller) *MockWords <span class="cov0" title="0">{
        mock := &amp;MockWords{ctrl: ctrl}
        mock.recorder = &amp;MockWordsMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWords) EXPECT() *MockWordsMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Norm mocks base method.
func (m *MockWords) Norm(ctx context.Context, phrase string) ([]string, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Norm", ctx, phrase)
        ret0, _ := ret[0].([]string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Norm indicates an expected call of Norm.
func (mr *MockWordsMockRecorder) Norm(ctx, phrase interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Norm", reflect.TypeOf((*MockWords)(nil).Norm), ctx, phrase)
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package words

import (
        "context"
        "fmt"
        "log/slog"

        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
        wordspb "yadro.com/course/proto/words"
)

type Client struct {
        log    *slog.Logger
        client wordspb.WordsClient
}

func NewClient(address string, log *slog.Logger) (*Client, error) <span class="cov1" title="1">{
        conn, err := grpc.NewClient(address, grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return &amp;Client{
                client: wordspb.NewWordsClient(conn),
                log:    log,
        }, nil</span>
}

func (c Client) Norm(ctx context.Context, phrase string) ([]string, error) <span class="cov10" title="3">{
        resp, err := c.client.Norm(ctx, &amp;wordspb.WordsRequest{Phrase: phrase})
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to normalize words: %w", err)
        }</span>
        <span class="cov6" title="2">return resp.Words, nil</span>
}

func (c Client) Ping(ctx context.Context) error <span class="cov6" title="2">{
        _, err := c.client.Ping(ctx, nil)
        return err
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package mock_xkcd

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        core "yadro.com/course/update/core"
)

// MockXKCD is a mock of XKCD interface.
type MockXKCD struct {
        ctrl     *gomock.Controller
        recorder *MockXKCDMockRecorder
}

// MockXKCDMockRecorder is the mock recorder for MockXKCD.
type MockXKCDMockRecorder struct {
        mock *MockXKCD
}

// NewMockXKCD creates a new mock instance.
func NewMockXKCD(ctrl *gomock.Controller) *MockXKCD <span class="cov1" title="1">{
        mock := &amp;MockXKCD{ctrl: ctrl}
        mock.recorder = &amp;MockXKCDMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockXKCD) EXPECT() *MockXKCDMockRecorder <span class="cov10" title="3">{
        return m.recorder
}</span>

// Get mocks base method.
func (m *MockXKCD) Get(arg0 context.Context, arg1 int) (core.XKCDInfo, error) <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Get", arg0, arg1)
        ret0, _ := ret[0].(core.XKCDInfo)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Get indicates an expected call of Get.
func (mr *MockXKCDMockRecorder) Get(arg0, arg1 interface{}) *gomock.Call <span class="cov1" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockXKCD)(nil).Get), arg0, arg1)
}</span>

// LastID mocks base method.
func (m *MockXKCD) LastID(arg0 context.Context) (int, error) <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "LastID", arg0)
        ret0, _ := ret[0].(int)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// LastID indicates an expected call of LastID.
func (mr *MockXKCDMockRecorder) LastID(arg0 interface{}) *gomock.Call <span class="cov1" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LastID", reflect.TypeOf((*MockXKCD)(nil).LastID), arg0)
}</span>

// MissingIds mocks base method.
func (m *MockXKCD) MissingIds(arg0 context.Context) []int <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "MissingIds", arg0)
        ret0, _ := ret[0].([]int)
        return ret0
}</span>

// MissingIds indicates an expected call of MissingIds.
func (mr *MockXKCDMockRecorder) MissingIds(arg0 interface{}) *gomock.Call <span class="cov1" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MissingIds", reflect.TypeOf((*MockXKCD)(nil).MissingIds), arg0)
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package xkcd

import (
        "context"
        "encoding/json"
        "fmt"
        "log/slog"
        "net/http"
        "sync"
        "time"

        "yadro.com/course/update/core"
)

type Client struct {
        log        *slog.Logger
        client     http.Client
        url        string
        missingIDs []int
        mu         sync.Mutex
}

func NewClient(url string, timeout time.Duration, log *slog.Logger) (*Client, error) <span class="cov10" title="10">{
        if url == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("empty base url specified")
        }</span>
        <span class="cov9" title="9">return &amp;Client{
                client: http.Client{Timeout: timeout},
                log:    log,
                url:    url,
        }, nil</span>
}

func (c *Client) Get(ctx context.Context, id int) (core.XKCDInfo, error) <span class="cov6" title="4">{
        url := fmt.Sprintf("%s/%d/info.0.json", c.url, id)
        resp, err := c.client.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return core.XKCDInfo{}, fmt.Errorf("failed to get comic %d: %w", id, err)
        }</span>
        <span class="cov6" title="4">defer resp.Body.Close()

        if resp.StatusCode == http.StatusNotFound </span><span class="cov3" title="2">{
                c.mu.Lock()
                c.missingIDs = append(c.missingIDs, id)
                c.mu.Unlock()
                return core.XKCDInfo{}, core.ErrNotFound
        }</span>

        <span class="cov3" title="2">if resp.StatusCode != http.StatusOK </span><span class="cov1" title="1">{
                return core.XKCDInfo{}, fmt.Errorf("failed to get comic %d: status %d", id, resp.StatusCode)
        }</span>
        <span class="cov1" title="1">info := struct {
                ID         int    `json:"num"`
                URL        string `json:"img"`
                Title      string `json:"title"`
                Transcript string `json:"transcript"`
                Alt        string `json:"alt"`
        }{}
        if err = json.NewDecoder(resp.Body).Decode(&amp;info); err != nil </span><span class="cov0" title="0">{
                return core.XKCDInfo{}, fmt.Errorf("failed to decode comics: %v", err)
        }</span>

        <span class="cov1" title="1">return core.XKCDInfo{
                NUM:         info.ID,
                URL:         info.URL,
                Title:       info.Title,
                Description: info.Transcript + info.Alt + info.Title,
        }, nil</span>
}

func (c *Client) LastID(ctx context.Context) (int, error) <span class="cov5" title="3">{
        resp, err := c.client.Get(c.url + "/info.0.json")
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get last comic: %w", err)
        }</span>
        <span class="cov5" title="3">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov1" title="1">{
                return 0, fmt.Errorf("failed to get last comic: status %d", resp.StatusCode)
        }</span>

        <span class="cov3" title="2">var info core.XKCDInfo
        if err := json.NewDecoder(resp.Body).Decode(&amp;info); err != nil </span><span class="cov1" title="1">{
                return 0, fmt.Errorf("failed to decode last comic: %w", err)
        }</span>

        <span class="cov1" title="1">return info.NUM, nil</span>
}

func (c *Client) MissingIds(ctx context.Context) []int <span class="cov5" title="3">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if c.missingIDs == nil </span><span class="cov1" title="1">{
                return []int{}
        }</span>

        <span class="cov3" title="2">missingIDsCopy := make([]int, len(c.missingIDs))
        copy(missingIDsCopy, c.missingIDs)

        return missingIDsCopy</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package config

import (
        "log"
        "time"

        "github.com/ilyakaznacheev/cleanenv"
)

type XKCD struct {
        URL         string        `yaml:"url" env:"XKCD_URL" env-default:"xkcd.com"`
        Concurrency int           `yaml:"concurrency" env:"XKCD_CONCURRENCY" env-default:"1"`
        Timeout     time.Duration `yaml:"timeout" env:"XKCD_TIMEOUT" env-default:"10s"`
        CheckPeriod time.Duration `yaml:"check_period" env:"XKCD_CHECK_PERIOD" env-default:"1h"`
}

type Config struct {
        LogLevel     string `yaml:"log_level" env:"LOG_LEVEL" env-default:"DEBUG"`
        Address      string `yaml:"update_address" env:"UPDATE_ADDRESS" env-default:"localhost:80"`
        XKCD         XKCD   `yaml:"xkcd"`
        DBAddress    string `yaml:"db_address" env:"DB_ADDRESS" env-default:"localhost:82"`
        WordsAddress string `yaml:"words_address" env:"WORDS_ADDRESS" env-default:"localhost:81"`
}

func MustLoad(configPath string) Config <span class="cov10" title="3">{
        var cfg Config
        if err := cleanenv.ReadConfig(configPath, &amp;cfg); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("cannot read config %q: %s", configPath, err)
        }</span>
        <span class="cov10" title="3">return cfg</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ports.go

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        core "yadro.com/course/update/core"
)

// MockUpdater is a mock of Updater interface.
type MockUpdater struct {
        ctrl     *gomock.Controller
        recorder *MockUpdaterMockRecorder
}

// MockUpdaterMockRecorder is the mock recorder for MockUpdater.
type MockUpdaterMockRecorder struct {
        mock *MockUpdater
}

// NewMockUpdater creates a new mock instance.
func NewMockUpdater(ctrl *gomock.Controller) *MockUpdater <span class="cov0" title="0">{
        mock := &amp;MockUpdater{ctrl: ctrl}
        mock.recorder = &amp;MockUpdaterMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUpdater) EXPECT() *MockUpdaterMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Drop mocks base method.
func (m *MockUpdater) Drop(arg0 context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Drop", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Drop indicates an expected call of Drop.
func (mr *MockUpdaterMockRecorder) Drop(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Drop", reflect.TypeOf((*MockUpdater)(nil).Drop), arg0)
}</span>

// Stats mocks base method.
func (m *MockUpdater) Stats(arg0 context.Context) (core.ServiceStats, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Stats", arg0)
        ret0, _ := ret[0].(core.ServiceStats)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Stats indicates an expected call of Stats.
func (mr *MockUpdaterMockRecorder) Stats(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stats", reflect.TypeOf((*MockUpdater)(nil).Stats), arg0)
}</span>

// Status mocks base method.
func (m *MockUpdater) Status(arg0 context.Context) core.ServiceStatus <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Status", arg0)
        ret0, _ := ret[0].(core.ServiceStatus)
        return ret0
}</span>

// Status indicates an expected call of Status.
func (mr *MockUpdaterMockRecorder) Status(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Status", reflect.TypeOf((*MockUpdater)(nil).Status), arg0)
}</span>

// Update mocks base method.
func (m *MockUpdater) Update(arg0 context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Update indicates an expected call of Update.
func (mr *MockUpdaterMockRecorder) Update(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockUpdater)(nil).Update), arg0)
}</span>

// MockDB is a mock of DB interface.
type MockDB struct {
        ctrl     *gomock.Controller
        recorder *MockDBMockRecorder
}

// MockDBMockRecorder is the mock recorder for MockDB.
type MockDBMockRecorder struct {
        mock *MockDB
}

// NewMockDB creates a new mock instance.
func NewMockDB(ctrl *gomock.Controller) *MockDB <span class="cov0" title="0">{
        mock := &amp;MockDB{ctrl: ctrl}
        mock.recorder = &amp;MockDBMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDB) EXPECT() *MockDBMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Add mocks base method.
func (m *MockDB) Add(arg0 context.Context, arg1 core.Comics) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Add", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Add indicates an expected call of Add.
func (mr *MockDBMockRecorder) Add(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Add", reflect.TypeOf((*MockDB)(nil).Add), arg0, arg1)
}</span>

// Drop mocks base method.
func (m *MockDB) Drop(arg0 context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Drop", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Drop indicates an expected call of Drop.
func (mr *MockDBMockRecorder) Drop(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Drop", reflect.TypeOf((*MockDB)(nil).Drop), arg0)
}</span>

// IDs mocks base method.
func (m *MockDB) IDs(arg0 context.Context) ([]int, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "IDs", arg0)
        ret0, _ := ret[0].([]int)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// IDs indicates an expected call of IDs.
func (mr *MockDBMockRecorder) IDs(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IDs", reflect.TypeOf((*MockDB)(nil).IDs), arg0)
}</span>

// Stats mocks base method.
func (m *MockDB) Stats(arg0 context.Context) (core.DBStats, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Stats", arg0)
        ret0, _ := ret[0].(core.DBStats)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Stats indicates an expected call of Stats.
func (mr *MockDBMockRecorder) Stats(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stats", reflect.TypeOf((*MockDB)(nil).Stats), arg0)
}</span>

// MockXKCD is a mock of XKCD interface.
type MockXKCD struct {
        ctrl     *gomock.Controller
        recorder *MockXKCDMockRecorder
}

// MockXKCDMockRecorder is the mock recorder for MockXKCD.
type MockXKCDMockRecorder struct {
        mock *MockXKCD
}

// NewMockXKCD creates a new mock instance.
func NewMockXKCD(ctrl *gomock.Controller) *MockXKCD <span class="cov0" title="0">{
        mock := &amp;MockXKCD{ctrl: ctrl}
        mock.recorder = &amp;MockXKCDMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockXKCD) EXPECT() *MockXKCDMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Get mocks base method.
func (m *MockXKCD) Get(arg0 context.Context, arg1 int) (core.XKCDInfo, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Get", arg0, arg1)
        ret0, _ := ret[0].(core.XKCDInfo)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Get indicates an expected call of Get.
func (mr *MockXKCDMockRecorder) Get(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockXKCD)(nil).Get), arg0, arg1)
}</span>

// LastID mocks base method.
func (m *MockXKCD) LastID(arg0 context.Context) (int, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "LastID", arg0)
        ret0, _ := ret[0].(int)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// LastID indicates an expected call of LastID.
func (mr *MockXKCDMockRecorder) LastID(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LastID", reflect.TypeOf((*MockXKCD)(nil).LastID), arg0)
}</span>

// MissingIds mocks base method.
func (m *MockXKCD) MissingIds(arg0 context.Context) []int <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "MissingIds", arg0)
        ret0, _ := ret[0].([]int)
        return ret0
}</span>

// MissingIds indicates an expected call of MissingIds.
func (mr *MockXKCDMockRecorder) MissingIds(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MissingIds", reflect.TypeOf((*MockXKCD)(nil).MissingIds), arg0)
}</span>

// MockWords is a mock of Words interface.
type MockWords struct {
        ctrl     *gomock.Controller
        recorder *MockWordsMockRecorder
}

// MockWordsMockRecorder is the mock recorder for MockWords.
type MockWordsMockRecorder struct {
        mock *MockWords
}

// NewMockWords creates a new mock instance.
func NewMockWords(ctrl *gomock.Controller) *MockWords <span class="cov0" title="0">{
        mock := &amp;MockWords{ctrl: ctrl}
        mock.recorder = &amp;MockWordsMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWords) EXPECT() *MockWordsMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Norm mocks base method.
func (m *MockWords) Norm(ctx context.Context, phrase string) ([]string, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Norm", ctx, phrase)
        ret0, _ := ret[0].([]string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Norm indicates an expected call of Norm.
func (mr *MockWordsMockRecorder) Norm(ctx, phrase interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Norm", reflect.TypeOf((*MockWords)(nil).Norm), ctx, phrase)
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package core

import (
        "context"
        "errors"
        "fmt"
        "log/slog"
        "sync"
)

type Service struct {
        log         *slog.Logger
        db          DB
        xkcd        XKCD
        words       Words
        concurrency int
        mu          sync.Mutex
        updates     bool
}

func NewService(
        log *slog.Logger, db DB, xkcd XKCD, words Words, concurrency int,
) (*Service, error) <span class="cov10" title="19">{
        if concurrency &lt; 1 </span><span class="cov3" title="2">{
                return nil, fmt.Errorf("wrong concurrency specified: %d", concurrency)
        }</span>
        <span class="cov9" title="17">return &amp;Service{
                log:         log,
                db:          db,
                xkcd:        xkcd,
                words:       words,
                concurrency: concurrency,
        }, nil</span>
}

func (s *Service) Update(ctx context.Context) (err error) <span class="cov7" title="8">{
        lastID, err := s.xkcd.LastID(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to get last id: %w", err)
        }</span>

        <span class="cov6" title="7">existIDs, err := s.db.IDs(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to get existing IDs: %w", err)
        }</span>

        <span class="cov6" title="6">existIDsMap := make(map[int]struct{}, len(existIDs))
        for _, id := range existIDs </span><span class="cov6" title="7">{
                existIDsMap[id] = struct{}{}
        }</span>

        <span class="cov6" title="6">var wg sync.WaitGroup
        sem := make(chan struct{}, s.concurrency)
        var errFinal error
        var once sync.Once

        for id := 1; id &lt;= lastID; id++ </span><span class="cov8" title="13">{
                if _, exists := existIDsMap[id]; exists </span><span class="cov6" title="7">{
                        continue</span>
                }

                <span class="cov6" title="6">wg.Add(1)
                sem &lt;- struct{}{}

                go func(id int) </span><span class="cov6" title="6">{
                        defer wg.Done()
                        defer func() </span><span class="cov6" title="6">{ &lt;-sem }</span>()

                        <span class="cov6" title="6">info, err := s.xkcd.Get(ctx, id)
                        if err != nil </span><span class="cov3" title="2">{
                                if errors.Is(err, ErrNotFound) </span><span class="cov1" title="1">{
                                        return
                                }</span>
                                <span class="cov1" title="1">once.Do(func() </span><span class="cov1" title="1">{
                                        errFinal = fmt.Errorf("failed to get comics %d: %w", id, err)
                                }</span>)
                                <span class="cov1" title="1">return</span>
                        }

                        <span class="cov5" title="4">words, err := s.words.Norm(ctx, info.Title+" "+info.Description)
                        if err != nil </span><span class="cov1" title="1">{
                                once.Do(func() </span><span class="cov1" title="1">{
                                        errFinal = fmt.Errorf("failed to normalize words for comics %d: %w", id, err)
                                }</span>)
                                <span class="cov1" title="1">return</span>
                        }

                        <span class="cov4" title="3">comics := Comics{
                                ID:    info.NUM,
                                URL:   info.URL,
                                Words: words,
                        }

                        if err := s.db.Add(ctx, comics); err != nil </span><span class="cov1" title="1">{
                                once.Do(func() </span><span class="cov1" title="1">{
                                        errFinal = fmt.Errorf("failed to add comics %d to db: %w", id, err)
                                }</span>)
                                <span class="cov1" title="1">return</span>
                        }
                }(id)
        }

        <span class="cov6" title="6">wg.Wait()

        return errFinal</span>
}

func (s *Service) Stats(ctx context.Context) (ServiceStats, error) <span class="cov4" title="3">{
        dbStats, err := s.db.Stats(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return ServiceStats{}, fmt.Errorf("failed to get db stats: %w", err)
        }</span>

        <span class="cov3" title="2">comicsTotal, err := s.Count(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return ServiceStats{}, fmt.Errorf("failed to count comics: %w", err)
        }</span>

        <span class="cov1" title="1">return ServiceStats{
                DBStats:     dbStats,
                ComicsTotal: comicsTotal,
        }, nil</span>
}

func (s *Service) Status(ctx context.Context) ServiceStatus <span class="cov1" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        if s.updates </span><span class="cov0" title="0">{
                return StatusRunning
        }</span>
        <span class="cov1" title="1">return StatusIdle</span>
}

func (s *Service) Drop(ctx context.Context) error <span class="cov3" title="2">{
        err := s.db.Drop(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to drop database: %w", err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func (s *Service) Count(ctx context.Context) (int, error) <span class="cov5" title="4">{
        lastID, err := s.xkcd.LastID(ctx)
        if err != nil </span><span class="cov3" title="2">{
                return 0, fmt.Errorf("failed to get last ID: %w", err)
        }</span>

        <span class="cov3" title="2">missingIDs := s.xkcd.MissingIds(ctx)
        return lastID - len(missingIDs), nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package main

import (
        "context"
        "flag"
        "fmt"
        "log/slog"
        "net"
        "os"
        "os/signal"

        "google.golang.org/grpc"
        "google.golang.org/grpc/reflection"
        updatepb "yadro.com/course/proto/update"
        "yadro.com/course/update/adapters/db"
        updategrpc "yadro.com/course/update/adapters/grpc"
        "yadro.com/course/update/adapters/words"
        "yadro.com/course/update/adapters/xkcd"
        "yadro.com/course/update/config"
        "yadro.com/course/update/core"
)

func main() <span class="cov0" title="0">{
        // config
        var configPath string
        flag.StringVar(&amp;configPath, "config", "config.yaml", "server configuration file")
        flag.Parse()
        cfg := config.MustLoad(configPath)

        // logger
        log := mustMakeLogger(cfg.LogLevel)

        log.Info("starting server")
        log.Debug("debug messages are enabled")

        if err := run(cfg, log); err != nil </span><span class="cov0" title="0">{
                slog.Error("fatal error", "error", err)
                os.Exit(1)
        }</span>
}

func run(cfg config.Config, log *slog.Logger) error <span class="cov0" title="0">{
        // database adapter
        storage, err := db.New(log, cfg.DBAddress)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to db: %w", err)
        }</span>
        <span class="cov0" title="0">if err := storage.Migrate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to migrate db: %w", err)
        }</span>

        // xkcd adapter
        <span class="cov0" title="0">xkcdClient, err := xkcd.NewClient(cfg.XKCD.URL, cfg.XKCD.Timeout, log)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create XKCD client: %w", err)
        }</span>

        // words adapter
        <span class="cov0" title="0">wordsClient, err := words.NewClient(cfg.WordsAddress, log)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create Words client: %w", err)
        }</span>

        // service
        <span class="cov0" title="0">updater, err := core.NewService(log, storage, xkcdClient, wordsClient, cfg.XKCD.Concurrency)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create Update service: %w", err)
        }</span>

        // grpc server
        <span class="cov0" title="0">listener, err := net.Listen("tcp", cfg.Address)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to listen: %w", err)
        }</span>
        <span class="cov0" title="0">s := grpc.NewServer()
        updatepb.RegisterUpdateServer(s, updategrpc.NewServer(updater))
        reflection.Register(s)

        // context for Ctrl-C
        ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt)
        defer stop()

        go func() </span><span class="cov0" title="0">{
                &lt;-ctx.Done()
                log.Debug("shutting down server")
                s.GracefulStop()
        }</span>()

        <span class="cov0" title="0">if err := s.Serve(listener); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to serve: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func mustMakeLogger(logLevel string) *slog.Logger <span class="cov0" title="0">{
        var level slog.Level
        switch logLevel </span>{
        case "DEBUG":<span class="cov0" title="0">
                level = slog.LevelDebug</span>
        case "INFO":<span class="cov0" title="0">
                level = slog.LevelInfo</span>
        case "ERROR":<span class="cov0" title="0">
                level = slog.LevelError</span>
        default:<span class="cov0" title="0">
                panic("unknown log level: " + logLevel)</span>
        }
        <span class="cov0" title="0">handler := slog.NewTextHandler(os.Stderr, &amp;slog.HandlerOptions{Level: level})
        return slog.New(handler)</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package main

import (
        "context"
        "flag"
        "fmt"
        "log/slog"
        "net"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/ilyakaznacheev/cleanenv"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/reflection"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/emptypb"
        wordspb "yadro.com/course/proto/words"
        "yadro.com/course/words/words"
)

const (
        maxPhraseLen    = 20480
        maxShutdownTime = 5 * time.Second
)

type Config struct {
        Port string `yaml:"words_address" env:"WORDS_ADDRESS" env-default:"8080"`
}

type server struct {
        wordspb.UnimplementedWordsServer
        log *slog.Logger
}

func (s *server) Ping(_ context.Context, in *emptypb.Empty) (*emptypb.Empty, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (s *server) Norm(_ context.Context, in *wordspb.WordsRequest) (*wordspb.WordsReply, error) <span class="cov0" title="0">{
        s.log.Debug("norm request", "phrase", in.Phrase)

        if len(in.GetPhrase()) &gt; maxPhraseLen </span><span class="cov0" title="0">{
                return nil, status.Error(codes.ResourceExhausted, "too large")
        }</span>

        <span class="cov0" title="0">return &amp;wordspb.WordsReply{
                Words: words.Norm(in.GetPhrase()),
        }, nil</span>
}

func main() <span class="cov0" title="0">{
        var configPath string
        flag.StringVar(&amp;configPath, "config", "config.yaml", "path to config file")
        flag.Parse()

        var config Config
        if err := cleanenv.ReadConfig(configPath, &amp;config); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">log := slog.New(
                slog.NewTextHandler(
                        os.Stdout,
                        &amp;slog.HandlerOptions{
                                AddSource: true,
                                Level:     slog.LevelDebug,
                        },
                ),
        )

        if err := run(config, log); err != nil </span><span class="cov0" title="0">{
                log.Error("failed to run server", "error", err)
                os.Exit(1)
        }</span>
}

func run(cfg Config, log *slog.Logger) error <span class="cov0" title="0">{
        listener, err := net.Listen("tcp", cfg.Port)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to listen port %s: %v", cfg.Port, err)
        }</span>

        <span class="cov0" title="0">s := grpc.NewServer()
        wordspb.RegisterWordsServer(s, &amp;server{log: log})
        reflection.Register(s)

        ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGTERM)
        defer stop()

        go func() </span><span class="cov0" title="0">{
                log.Info("starting server", "port", cfg.Port)
                if err = s.Serve(listener); err != nil </span><span class="cov0" title="0">{
                        log.Error("faied to serve", "error", err)
                        stop()
                }</span>
        }()

        <span class="cov0" title="0">&lt;-ctx.Done()

        timer := time.AfterFunc(maxShutdownTime, func() </span><span class="cov0" title="0">{
                log.Info("forcing server stop")
                s.Stop()
        }</span>)
        <span class="cov0" title="0">defer timer.Stop()

        log.Info("starting graceful stop")
        s.GracefulStop()
        log.Info("server stopped")

        return err</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package words

import (
        "maps"
        "slices"
        "strings"
        "unicode"

        "github.com/kljensen/snowball"
        "github.com/kljensen/snowball/english"
)

func Norm(phrase string) []string <span class="cov4" title="10">{

        f := func(c rune) bool </span><span class="cov10" title="209">{
                return unicode.IsPunct(c) || unicode.IsSpace(c) || c == '+'
        }</span>

        <span class="cov4" title="10">split := strings.FieldsFunc(phrase, f)
        words := make(map[string]bool)

        for _, word := range split </span><span class="cov7" title="38">{
                stemmed, _ := snowball.Stem(word, "english", false)

                if english.IsStopWord(stemmed) </span><span class="cov4" title="10">{
                        continue</span>
                }
                <span class="cov6" title="28">words[stemmed] = true</span>
        }

        <span class="cov4" title="10">return slices.Collect(maps.Keys(words))</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package main

import (
        "bytes"
        "context"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "github.com/ilyakaznacheev/cleanenv"
        "google.golang.org/grpc"
        "google.golang.org/grpc/reflection"
        "io/ioutil"
        "log"
        "log/slog"
        "net"
        "net/http"
        "os"
        "strconv"
        yolopb "yadro.com/course/proto/yolo"
)

type Config struct {
        Port string `yaml:"yolo_address" env:"YOLO_ADDRESS" env-default:":28085"`
        Yolo string `yaml:"yolo_api_address" env:"YOLO_API_ADDRESS" env-default:":10004"`
}

type server struct {
        yolopb.UnimplementedYoloServiceServer
        log  *slog.Logger
        port string
        url  string
}

func (s *server) Detect(ctx context.Context, req *yolopb.DetectRequest) (*yolopb.DetectResponse, error) <span class="cov0" title="0">{
        binaryImage := req.ImageData

        data := map[string]interface{}{
                "image": map[string]interface{}{
                        "py/b64": base64.StdEncoding.EncodeToString(binaryImage),
                },
        }

        jsonData, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("marshal error: %w", err)
        }</span>

        <span class="cov0" title="0">var tmp interface{}
        if err := json.Unmarshal(jsonData, &amp;tmp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unmarshal error: %w", err)
        }</span>
        <span class="cov0" title="0">finalData, err := json.Marshal(tmp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("marshal error: %w", err)
        }</span>

        <span class="cov0" title="0">escapedJsonString := strconv.Quote(string(finalData))

        resp, err := http.Post(
                "http://172.21.0.1:10004",
                "application/json",
                bytes.NewBuffer([]byte(escapedJsonString)),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("request failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("read response error: %w", err)
        }</span>

        <span class="cov0" title="0">var responseDecoded map[string]interface{}
        if err := json.Unmarshal(body, &amp;responseDecoded); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error decoding response: %v", err)
        }</span>

        <span class="cov0" title="0">var response struct {
                YoloResults []struct {
                        BBox     []float64 `json:"bbox"`
                        DetScore float64   `json:"det_score"`
                        LabelNum int       `json:"label_num"`
                        Label    string    `json:"label_string"`
                } `json:"yolo_results"`
        }

        if err := json.Unmarshal(body, &amp;response); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("decode response error: %w", err)
        }</span>

        <span class="cov0" title="0">results := make([]*yolopb.Detection, len(response.YoloResults))
        for i, r := range response.YoloResults </span><span class="cov0" title="0">{

                bbox := make([]float32, len(r.BBox))
                for j, val := range r.BBox </span><span class="cov0" title="0">{
                        bbox[j] = float32(val)
                }</span>

                <span class="cov0" title="0">results[i] = &amp;yolopb.Detection{
                        Bbox:       bbox,
                        Confidence: float32(r.DetScore),
                        Label:      r.Label,
                        LabelNum:   int32(r.LabelNum),
                }</span>
        }

        <span class="cov0" title="0">return &amp;yolopb.DetectResponse{Results: results}, nil</span>
}

func main() <span class="cov0" title="0">{
        var cfg Config
        if err := cleanenv.ReadEnv(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to read config: %v", err)
        }</span>

        <span class="cov0" title="0">log := slog.New(slog.NewTextHandler(os.Stdout, &amp;slog.HandlerOptions{
                Level: slog.LevelDebug,
        }))

        if err := run(cfg, log); err != nil </span><span class="cov0" title="0">{
                log.Error("failed to run server", "error", err)
                os.Exit(1)
        }</span>
}

func run(cfg Config, log *slog.Logger) error <span class="cov0" title="0">{
        lis, err := net.Listen("tcp", cfg.Port)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to listen: %v", err)
        }</span>

        <span class="cov0" title="0">srv := grpc.NewServer()
        yolopb.RegisterYoloServiceServer(srv, &amp;server{
                log:  log,
                port: cfg.Port,
                url:  cfg.Yolo,
        })
        reflection.Register(srv)

        log.Info("starting server", "address", cfg.Port)

        return srv.Serve(lis)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
